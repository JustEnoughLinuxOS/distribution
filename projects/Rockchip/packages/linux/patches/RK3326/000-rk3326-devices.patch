diff -rupN linux.orig/arch/arm64/boot/dts/rockchip/Makefile linux/arch/arm64/boot/dts/rockchip/Makefile
--- linux.orig/arch/arm64/boot/dts/rockchip/Makefile	2023-10-27 21:46:01.208549984 +0000
+++ linux/arch/arm64/boot/dts/rockchip/Makefile	2023-10-28 04:02:49.341614140 +0000
@@ -7,7 +7,11 @@ dtb-$(CONFIG_ARCH_ROCKCHIP) += rk3308-ev
 dtb-$(CONFIG_ARCH_ROCKCHIP) += rk3308-roc-cc.dtb
 dtb-$(CONFIG_ARCH_ROCKCHIP) += rk3308-rock-pi-s.dtb
 dtb-$(CONFIG_ARCH_ROCKCHIP) += rk3318-a95x-z2.dtb
+dtb-$(CONFIG_ARCH_ROCKCHIP) += rk3326-anbernic-rg351m.dtb
+dtb-$(CONFIG_ARCH_ROCKCHIP) += rk3326-anbernic-rg351v.dtb
 dtb-$(CONFIG_ARCH_ROCKCHIP) += rk3326-odroid-go2.dtb
+dtb-$(CONFIG_ARCH_ROCKCHIP) += rk3326-odroid-go2-v11.dtb
+dtb-$(CONFIG_ARCH_ROCKCHIP) += rk3326-odroid-go3.dtb
 dtb-$(CONFIG_ARCH_ROCKCHIP) += rk3328-a1.dtb
 dtb-$(CONFIG_ARCH_ROCKCHIP) += rk3328-evb.dtb
 dtb-$(CONFIG_ARCH_ROCKCHIP) += rk3328-nanopi-r2s.dtb
diff -rupN linux.orig/arch/arm64/boot/dts/rockchip/px30.dtsi linux/arch/arm64/boot/dts/rockchip/px30.dtsi
--- linux.orig/arch/arm64/boot/dts/rockchip/px30.dtsi	2023-10-27 21:46:01.208549984 +0000
+++ linux/arch/arm64/boot/dts/rockchip/px30.dtsi	2023-10-28 04:02:49.341614140 +0000
@@ -114,12 +114,6 @@
 		compatible = "operating-points-v2";
 		opp-shared;
 
-		opp-600000000 {
-			opp-hz = /bits/ 64 <600000000>;
-			opp-microvolt = <950000 950000 1350000>;
-			clock-latency-ns = <40000>;
-			opp-suspend;
-		};
 		opp-816000000 {
 			opp-hz = /bits/ 64 <816000000>;
 			opp-microvolt = <1050000 1050000 1350000>;
@@ -210,12 +204,6 @@
 					cooling-device = <&cpu0 THERMAL_NO_LIMIT THERMAL_NO_LIMIT>;
 					contribution = <4096>;
 				};
-
-				map1 {
-					trip = <&target>;
-					cooling-device = <&gpu THERMAL_NO_LIMIT THERMAL_NO_LIMIT>;
-					contribution = <4096>;
-				};
 			};
 		};
 
@@ -223,6 +211,33 @@
 			polling-delay-passive = <100>; /* milliseconds */
 			polling-delay = <1000>; /* milliseconds */
 			thermal-sensors = <&tsadc 1>;
+
+			trips {
+				gpu_threshold: gpu-threshold {
+					temperature = <70000>;
+					hysteresis = <2000>;
+					type = "passive";
+				};
+
+				gpu_target: gpu-target {
+					temperature = <85000>;
+					hysteresis = <2000>;
+					type = "passive";
+				};
+
+				gpu_crit: gpu-crit {
+					temperature = <115000>;
+					hysteresis = <2000>;
+					type = "critical";
+				};
+			};
+
+			cooling-maps {
+				map0 {
+					trip = <&gpu_target>;
+					cooling-device = <&gpu THERMAL_NO_LIMIT THERMAL_NO_LIMIT>;
+				};
+			};
 		};
 	};
 
@@ -328,6 +343,32 @@
 		};
 	};
 
+	dfi: dfi@ff610000 {
+		reg = <0x00 0xff610000 0x00 0x400>;
+		compatible = "rockchip,px30-dfi";
+		rockchip,pmu = <&pmugrf>;
+		status = "okay";
+	};
+
+	dmc: dmc {
+		compatible = "rockchip,px30-dmc";
+		devfreq-events = <&dfi>;
+		clocks = <&cru SCLK_DDRCLK>;
+		clock-names = "dmc_clk";
+		operating-points-v2 = <&dmc_opp_table>;
+		uptreshold = <40>;
+		downdifferential = <20>;
+		status = "okay";
+	};
+
+	dmc_opp_table: dmc_opp_table {
+		compatible = "operating-points-v2";
+		opp-786000000 {
+			opp-hz = /bits/ 64 <786000000>;
+			opp-microvolt = <1125000>;
+		};
+	};
+
 	pmugrf: syscon@ff010000 {
 		compatible = "rockchip,px30-pmugrf", "syscon", "simple-mfd";
 		reg = <0x0 0xff010000 0x0 0x1000>;
@@ -453,7 +494,7 @@
 				#address-cells = <1>;
 				#size-cells = <0>;
 
-				port@0 {
+				lvds_in: port@0 {
 					reg = <0>;
 					#address-cells = <1>;
 					#size-cells = <0>;
@@ -468,6 +509,10 @@
 						remote-endpoint = <&vopl_out_lvds>;
 					};
 				};
+
+				lvds_out: port@1 {
+					reg = <1>;
+				};
 			};
 		};
 	};
@@ -1039,10 +1084,6 @@
 	gpu_opp_table: opp-table-1 {
 		compatible = "operating-points-v2";
 
-		opp-200000000 {
-			opp-hz = /bits/ 64 <200000000>;
-			opp-microvolt = <950000>;
-		};
 		opp-300000000 {
 			opp-hz = /bits/ 64 <300000000>;
 			opp-microvolt = <975000>;
@@ -1051,8 +1092,8 @@
 			opp-hz = /bits/ 64 <400000000>;
 			opp-microvolt = <1050000>;
 		};
-		opp-480000000 {
-			opp-hz = /bits/ 64 <480000000>;
+		opp-440000000 {
+			opp-hz = /bits/ 64 <440000000>;
 			opp-microvolt = <1125000>;
 		};
 	};
@@ -1113,7 +1154,7 @@
 			#address-cells = <1>;
 			#size-cells = <0>;
 
-			port@0 {
+			dsi_in: port@0 {
 				reg = <0>;
 				#address-cells = <1>;
 				#size-cells = <0>;
@@ -1128,6 +1169,10 @@
 					remote-endpoint = <&vopl_out_dsi>;
 				};
 			};
+
+			dsi_out: port@1 {
+				reg = <1>;
+			};
 		};
 	};
 
diff -rupN linux.orig/arch/arm64/boot/dts/rockchip/rk3326-anbernic-rg351m.dts linux/arch/arm64/boot/dts/rockchip/rk3326-anbernic-rg351m.dts
--- linux.orig/arch/arm64/boot/dts/rockchip/rk3326-anbernic-rg351m.dts	1970-01-01 00:00:00.000000000 +0000
+++ linux/arch/arm64/boot/dts/rockchip/rk3326-anbernic-rg351m.dts	2023-10-28 04:02:49.341614140 +0000
@@ -0,0 +1,58 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Copyright (c) 2019 Hardkernel Co., Ltd
+ * Copyright (c) 2020 Theobroma Systems Design und Consulting GmbH
+ * Copyright (c) 2022 Maya Matuszczyk <maccraft123mc@gmail.com>
+ */
+
+/dts-v1/;
+#include "rk3326-odroid-go.dtsi"
+
+/ {
+	model = "Anbernic RG351M";
+	compatible = "anbernic,rg351m", "rockchip,rk3326";
+
+        battery: battery {
+               compatible = "simple-battery";
+               charge-full-design-microamp-hours = <3500000>;
+               charge-term-current-microamp = <350000>;
+               constant-charge-current-max-microamp = <2000000>;
+               constant-charge-voltage-max-microvolt = <4200000>;
+               factory-internal-resistance-micro-ohms = <180000>;
+               voltage-max-design-microvolt = <4100000>;
+               voltage-min-design-microvolt = <3500000>;
+
+               ocv-capacity-celsius = <20>;
+               ocv-capacity-table-0 =  <4046950 100>, <4001920 95>, <3967900 90>, <3919950 85>,
+                                       <3888450 80>, <3861850 75>, <3831540 70>, <3799130 65>,
+                                       <3768190 60>, <3745650 55>, <3726610 50>, <3711630 45>,
+                                       <3696720 40>, <3685660 35>, <3674950 30>, <3663050 25>,
+                                       <3649470 20>, <3635260 15>, <3616920 10>, <3592440 5>,
+                                       <3574170 0>;
+       };
+
+	vibrator {
+		compatible = "pwm-vibrator";
+		pwms = <&pwm0 0 1000000 0>;
+		pwm-names = "enable";
+	};
+};
+
+/delete-node/ &vcc_host; /* conflicts with pwm vibration motor */
+
+&internal_display {
+	compatible = "elida,kd35t133";
+	iovcc-supply = <&vcc_lcd>;
+	vdd-supply = <&vcc_lcd>;
+	rotation = <270>;
+};
+
+&pwm0 {
+	status = "okay";
+};
+
+&rk817_charger {
+       /* This device does not have a current sense resistor */
+       //rockchip,resistor-sense-micro-ohms = <0>;
+       monitored-battery = <&battery>;
+};
diff -rupN linux.orig/arch/arm64/boot/dts/rockchip/rk3326-anbernic-rg351p.dts linux/arch/arm64/boot/dts/rockchip/rk3326-anbernic-rg351p.dts
--- linux.orig/arch/arm64/boot/dts/rockchip/rk3326-anbernic-rg351p.dts	1970-01-01 00:00:00.000000000 +0000
+++ linux/arch/arm64/boot/dts/rockchip/rk3326-anbernic-rg351p.dts	2023-10-28 04:02:49.341614140 +0000
@@ -0,0 +1,57 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Copyright (c) 2019 Hardkernel Co., Ltd
+ * Copyright (c) 2020 Theobroma Systems Design und Consulting GmbH
+ * Copyright (c) 2022 Maya Matuszczyk <maccraft123mc@gmail.com>
+ */
+
+/dts-v1/;
+#include "rk3326-odroid-go.dtsi"
+
+/ {
+	model = "Anbernic RG351V";
+	compatible = "anbernic,rg351v", "rockchip,rk3326";
+
+        battery: battery {
+               compatible = "simple-battery";
+               charge-full-design-microamp-hours = <3500000>;
+               charge-term-current-microamp = <350000>;
+               constant-charge-current-max-microamp = <2000000>;
+               constant-charge-voltage-max-microvolt = <4200000>;
+               factory-internal-resistance-micro-ohms = <180000>;
+               voltage-max-design-microvolt = <4100000>;
+               voltage-min-design-microvolt = <3500000>;
+
+               ocv-capacity-celsius = <20>;
+               ocv-capacity-table-0 =  <4046950 100>, <4001920 95>, <3967900 90>, <3919950 85>,
+                                       <3888450 80>, <3861850 75>, <3831540 70>, <3799130 65>,
+                                       <3768190 60>, <3745650 55>, <3726610 50>, <3711630 45>,
+                                       <3696720 40>, <3685660 35>, <3674950 30>, <3663050 25>,
+                                       <3649470 20>, <3635260 15>, <3616920 10>, <3592440 5>,
+                                       <3574170 0>;
+       };
+
+	vibrator {
+		compatible = "pwm-vibrator";
+		pwms = <&pwm0 0 1000000 0>;
+		pwm-names = "enable";
+	};
+};
+
+/delete-node/ &vcc_host; /* conflicts with pwm vibration motor */
+
+&internal_display {
+	compatible = "anbernic,rg351v-panel", "newvision,nv3051d";
+	iovcc-supply = <&vcc_lcd>;
+	vdd-supply = <&vcc_lcd>;
+};
+
+&pwm0 {
+	status = "okay";
+};
+
+&rk817_charger {
+       /* This device does not have a current sense resistor */
+       rockchip,resistor-sense-micro-ohms = <0>;
+       monitored-battery = <&battery>;
+};
diff -rupN linux.orig/arch/arm64/boot/dts/rockchip/rk3326-anbernic-rg351v.dts linux/arch/arm64/boot/dts/rockchip/rk3326-anbernic-rg351v.dts
--- linux.orig/arch/arm64/boot/dts/rockchip/rk3326-anbernic-rg351v.dts	1970-01-01 00:00:00.000000000 +0000
+++ linux/arch/arm64/boot/dts/rockchip/rk3326-anbernic-rg351v.dts	2023-10-28 04:02:49.341614140 +0000
@@ -0,0 +1,124 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Copyright (c) 2019 Hardkernel Co., Ltd
+ * Copyright (c) 2020 Theobroma Systems Design und Consulting GmbH
+ * Copyright (c) 2022 Maya Matuszczyk <maccraft123mc@gmail.com>
+ */
+
+/dts-v1/;
+#include "rk3326-odroid-go.dtsi"
+
+/ {
+	model = "Anbernic RG351V";
+	compatible = "anbernic,rg351v", "rockchip,rk3326";
+
+       aliases {
+               mmc0 = &sdio;
+               mmc1 = &sdmmc;
+       };
+
+        gpio-keys-vol {
+                compatible = "gpio-keys";
+                autorepeat;
+                pinctrl-0 = <&btn_pins_vol>;
+                pinctrl-names = "default";
+
+                button-vol-down {
+                        gpios = <&gpio2 RK_PA1 GPIO_ACTIVE_LOW>;
+                        label = "VOLUMEDOWN";
+                        linux,code = <KEY_VOLUMEDOWN>;
+                };
+
+                button-volume-up {
+                        gpios = <&gpio2 RK_PA0 GPIO_ACTIVE_LOW>;
+                        label = "VOLUMEUP";
+                        linux,code = <KEY_VOLUMEUP>;
+                };
+        };
+
+        battery: battery {
+               compatible = "simple-battery";
+               charge-full-design-microamp-hours = <3500000>;
+               charge-term-current-microamp = <350000>;
+               constant-charge-current-max-microamp = <2000000>;
+               constant-charge-voltage-max-microvolt = <4200000>;
+               factory-internal-resistance-micro-ohms = <180000>;
+               voltage-max-design-microvolt = <4100000>;
+               voltage-min-design-microvolt = <3500000>;
+
+               ocv-capacity-celsius = <20>;
+               ocv-capacity-table-0 =  <4046950 100>, <4001920 95>, <3967900 90>, <3919950 85>,
+                                       <3888450 80>, <3861850 75>, <3831540 70>, <3799130 65>,
+                                       <3768190 60>, <3745650 55>, <3726610 50>, <3711630 45>,
+                                       <3696720 40>, <3685660 35>, <3674950 30>, <3663050 25>,
+                                       <3649470 20>, <3635260 15>, <3616920 10>, <3592440 5>,
+                                       <3574170 0>;
+       };
+
+	vibrator {
+		compatible = "pwm-vibrator";
+		pwms = <&pwm0 0 1000000 0>;
+		pwm-names = "enable";
+	};
+};
+
+/* conflicts with pwm vibration motor */
+/delete-node/ &vcc_host;
+
+/* Device only has 1 LED compared to Odroid Go Advance */
+/delete-node/ &gpio_led;
+
+&internal_display {
+	compatible = "anbernic,rg351v-panel", "newvision,nv3051d";
+	iovcc-supply = <&vcc_lcd>;
+	vdd-supply = <&vcc_lcd>;
+};
+
+&io_domains {
+	vccio1-supply = <&vccio_sd>;
+};
+
+/delete-node/ &pwm_led;
+
+&pwm0 {
+	status = "okay";
+};
+
+/delete-node/ &pwm3;
+
+&rk817_charger {
+       /* This device does not have a current sense resistor */
+       rockchip,resistor-sense-micro-ohms = <0>;
+       monitored-battery = <&battery>;
+};
+
+&sdio {
+	cap-sd-highspeed;
+	card-detect-delay = <200>;
+	cd-gpios = <&gpio3 RK_PB4 GPIO_ACTIVE_LOW>; /*[> CD GPIO <]*/
+	sd-uhs-sdr12;
+	sd-uhs-sdr25;
+	sd-uhs-sdr50;
+	sd-uhs-sdr104;
+	vmmc-supply = <&vcc_sd>;
+	vqmmc-supply = <&vccio_sd>;
+	status = "okay";
+};
+
+&vcc_sd {
+	regulator-max-microvolt = <3000000>;
+	regulator-min-microvolt = <1800000>;
+};
+
+&vccio_sd {
+	regulator-max-microvolt = <1800000>;
+};
+
+&pinctrl {
+        btns {
+                btn_pins_vol: btn-pins-vol {
+                        rockchip,pins = <2 RK_PA0 RK_FUNC_GPIO &pcfg_pull_up>,
+                                        <2 RK_PA1 RK_FUNC_GPIO &pcfg_pull_up>;
+                };
+        };
+};
diff -rupN linux.orig/arch/arm64/boot/dts/rockchip/rk3326-odroid-go.dtsi linux/arch/arm64/boot/dts/rockchip/rk3326-odroid-go.dtsi
--- linux.orig/arch/arm64/boot/dts/rockchip/rk3326-odroid-go.dtsi	1970-01-01 00:00:00.000000000 +0000
+++ linux/arch/arm64/boot/dts/rockchip/rk3326-odroid-go.dtsi	2023-10-28 04:02:49.341614140 +0000
@@ -0,0 +1,566 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Copyright (c) 2019 Hardkernel Co., Ltd
+ * Copyright (c) 2020 Theobroma Systems Design und Consulting GmbH
+ * Copyright (c) 2022 Maya Matuszczyk <maccraft123mc@gmail.com>
+ */
+
+/dts-v1/;
+#include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/input/input.h>
+#include <dt-bindings/leds/common.h>
+#include <dt-bindings/pinctrl/rockchip.h>
+#include "rk3326.dtsi"
+
+/ {
+	aliases {
+		mmc0 = &sdmmc;
+	};
+
+	chosen {
+		stdout-path = "serial2:115200n8";
+	};
+
+	backlight: backlight {
+		compatible = "pwm-backlight";
+		power-supply = <&vcc_bl>;
+		pwms = <&pwm1 0 25000 0>;
+		brightness-levels = <
+		  0   1   2   3   4   5   6   7
+		  8   9  10  11  12  13  14  15
+		 16  17  18  19  20  21  22  23
+		 24  25  26  27  28  29  30  31
+		 32  33  34  35  36  37  38  39
+		 40  41  42  43  44  45  46  47
+		 48  49  50  51  52  53  54  55
+		 56  57  58  59  60  61  62  63
+		 64  65  66  67  68  69  70  71
+		 72  73  74  75  76  77  78  79
+		 80  81  82  83  84  85  86  87
+		 88  89  90  91  92  93  94  95
+		 96  97  98  99 100 101 102 103
+		104 105 106 107 108 109 110 111
+		112 113 114 115 116 117 118 119
+		120 121 122 123 124 125 126 127
+		128 129 130 131 132 133 134 135
+		136 137 138 139 140 141 142 143
+		144 145 146 147 148 149 150 151
+		152 153 154 155 156 157 158 159
+		160 161 162 163 164 165 166 167
+		168 169 170 171 172 173 174 175
+		176 177 178 179 180 181 182 183
+		184 185 186 187 188 189 190 191
+		192 193 194 195 196 197 198 199
+		200 201 202 203 204 205 206 207
+		208 209 210 211 212 213 214 215
+		216 217 218 219 220 221 222 223
+		224 225 226 227 228 229 230 231
+		232 233 234 235 236 237 238 239
+		240 241 242 243 244 245 246 247
+		248 249 250 251 252 253 254 255>;
+		default-brightness-level = <128>;
+	};
+
+	/* led-1 is wired directly to output of always-on regulator */
+
+	gpio_led: gpio-leds {
+		compatible = "gpio-leds";
+		pinctrl-names = "default";
+		pinctrl-0 = <&red_led_pin>;
+
+		red_led: led-3 {
+			color = <LED_COLOR_ID_RED>;
+			gpios = <&gpio0 RK_PB5 GPIO_ACTIVE_HIGH>;
+			function = LED_FUNCTION_CHARGING;
+		};
+	};
+
+	pwm_led: led-controller {
+		compatible = "pwm-leds";
+
+		blue_led: led-2 {
+			color = <LED_COLOR_ID_BLUE>;
+			function = LED_FUNCTION_STATUS;
+			linux,default-trigger = "heartbeat";
+			max-brightness = <255>;
+			pwms = <&pwm3 0 25000 0>;
+		};
+	};
+
+	rk817-sound {
+		compatible = "simple-audio-card";
+		simple-audio-card,name = "rk817_int";
+		simple-audio-card,format = "i2s";
+		simple-audio-card,hp-det-gpio = <&gpio2 RK_PC6 GPIO_ACTIVE_HIGH>;
+		simple-audio-card,mclk-fs = <256>;
+		simple-audio-card,widgets =
+			"Microphone", "Mic Jack",
+			"Headphone", "Headphones",
+			"Speaker", "Speaker";
+		simple-audio-card,routing =
+			"MICL", "Mic Jack",
+			"Headphones", "HPOL",
+			"Headphones", "HPOR",
+			"Speaker", "SPKO";
+
+		simple-audio-card,codec {
+			sound-dai = <&rk817>;
+		};
+
+		simple-audio-card,cpu {
+			sound-dai = <&i2s1_2ch>;
+		};
+	};
+
+	vccsys: vccsys {
+		compatible = "regulator-fixed";
+		regulator-name = "vcc3v8_sys";
+		regulator-always-on;
+		regulator-min-microvolt = <3800000>;
+		regulator-max-microvolt = <3800000>;
+	};
+
+	vcc_host: vcc_host {
+		compatible = "regulator-fixed";
+		regulator-name = "vcc_host";
+		regulator-min-microvolt = <5000000>;
+		regulator-max-microvolt = <5000000>;
+
+		gpio = <&gpio0 RK_PB7 GPIO_ACTIVE_HIGH>;
+		enable-active-high;
+		regulator-always-on;
+		regulator-boot-on;
+		vin-supply = <&usb_midu>;
+	};
+};
+
+&dmc {
+	center-supply = <&vdd_logic>;
+};
+
+&cpu0 {
+	cpu-supply = <&vdd_arm>;
+};
+
+&cpu1 {
+	cpu-supply = <&vdd_arm>;
+};
+
+&cpu2 {
+	cpu-supply = <&vdd_arm>;
+};
+
+&cpu3 {
+	cpu-supply = <&vdd_arm>;
+};
+
+&cru {
+	assigned-clocks = <&cru PLL_NPLL>,
+		<&cru ACLK_BUS_PRE>, <&cru ACLK_PERI_PRE>,
+		<&cru HCLK_BUS_PRE>, <&cru HCLK_PERI_PRE>,
+		<&cru PCLK_BUS_PRE>, <&cru SCLK_GPU>;
+
+	assigned-clock-rates = <1188000000>,
+		<200000000>, <200000000>,
+		<150000000>, <150000000>,
+		<100000000>, <200000000>;
+};
+
+&display_subsystem {
+	status = "okay";
+};
+
+&dsi {
+	status = "okay";
+
+	ports {
+		mipi_out: port@1 {
+			reg = <1>;
+
+			mipi_out_panel: endpoint {
+				remote-endpoint = <&mipi_in_panel>;
+			};
+		};
+	};
+
+	internal_display: panel@0 {
+		reg = <0>;
+		backlight = <&backlight>;
+		reset-gpios = <&gpio3 RK_PC0 GPIO_ACTIVE_LOW>;
+
+		port {
+			mipi_in_panel: endpoint {
+				remote-endpoint = <&mipi_out_panel>;
+			};
+		};
+	};
+};
+
+&dsi_dphy {
+	status = "okay";
+};
+
+&gpu {
+	mali-supply = <&vdd_logic>;
+	status = "okay";
+};
+
+&i2c0 {
+	clock-frequency = <400000>;
+	i2c-scl-falling-time-ns = <16>;
+	i2c-scl-rising-time-ns = <280>;
+	status = "okay";
+
+	rk817: pmic@20 {
+		compatible = "rockchip,rk817";
+		reg = <0x20>;
+		interrupt-parent = <&gpio0>;
+		interrupts = <RK_PB2 IRQ_TYPE_LEVEL_LOW>;
+		clock-output-names = "rk808-clkout1", "xin32k";
+		clock-names = "mclk";
+		clocks = <&cru SCLK_I2S1_OUT>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&pmic_int>, <&i2s1_2ch_mclk>;
+		rockchip,system-power-controller;
+		wakeup-source;
+		#clock-cells = <1>;
+		#sound-dai-cells = <0>;
+
+		vcc1-supply = <&vccsys>;
+		vcc2-supply = <&vccsys>;
+		vcc3-supply = <&vccsys>;
+		vcc4-supply = <&vccsys>;
+		vcc5-supply = <&vccsys>;
+		vcc6-supply = <&vccsys>;
+		vcc7-supply = <&vccsys>;
+		vcc8-supply = <&vccsys>;
+
+		regulators {
+			vdd_logic: DCDC_REG1 {
+				regulator-name = "vdd_logic";
+				regulator-min-microvolt = <950000>;
+				regulator-max-microvolt = <1150000>;
+				regulator-ramp-delay = <6001>;
+				regulator-always-on;
+				regulator-boot-on;
+
+				regulator-state-mem {
+					regulator-on-in-suspend;
+					regulator-suspend-microvolt = <950000>;
+				};
+			};
+
+			vdd_arm: DCDC_REG2 {
+				regulator-name = "vdd_arm";
+				regulator-min-microvolt = <950000>;
+				regulator-max-microvolt = <1350000>;
+				regulator-ramp-delay = <6001>;
+				regulator-always-on;
+				regulator-boot-on;
+
+				regulator-state-mem {
+					regulator-off-in-suspend;
+					regulator-suspend-microvolt = <950000>;
+				};
+			};
+
+			vcc_ddr: DCDC_REG3 {
+				regulator-name = "vcc_ddr";
+				regulator-always-on;
+				regulator-boot-on;
+
+				regulator-state-mem {
+					regulator-on-in-suspend;
+				};
+			};
+
+			vcc_3v3: DCDC_REG4 {
+				regulator-name = "vcc_3v3";
+				regulator-min-microvolt = <3300000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+				regulator-boot-on;
+
+				regulator-state-mem {
+					regulator-off-in-suspend;
+					regulator-suspend-microvolt = <3300000>;
+				};
+			};
+
+			vcc_1v8: LDO_REG2 {
+				regulator-name = "vcc_1v8";
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <1800000>;
+				regulator-always-on;
+				regulator-boot-on;
+
+				regulator-state-mem {
+					regulator-on-in-suspend;
+					regulator-suspend-microvolt = <1800000>;
+				};
+			};
+
+			vdd_1v0: LDO_REG3 {
+				regulator-name = "vdd_1v0";
+				regulator-min-microvolt = <1000000>;
+				regulator-max-microvolt = <1000000>;
+				regulator-always-on;
+				regulator-boot-on;
+
+				regulator-state-mem {
+					regulator-on-in-suspend;
+					regulator-suspend-microvolt = <1000000>;
+				};
+			};
+
+			vcc3v3_pmu: LDO_REG4 {
+				regulator-name = "vcc3v3_pmu";
+				regulator-min-microvolt = <3300000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+				regulator-boot-on;
+
+				regulator-state-mem {
+					regulator-on-in-suspend;
+					regulator-suspend-microvolt = <3300000>;
+				};
+			};
+
+			vccio_sd: LDO_REG5 {
+				regulator-name = "vccio_sd";
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+				regulator-boot-on;
+
+				regulator-state-mem {
+					regulator-on-in-suspend;
+					regulator-suspend-microvolt = <3300000>;
+				};
+			};
+
+			vcc_sd: LDO_REG6 {
+				regulator-name = "vcc_sd";
+				regulator-min-microvolt = <3300000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-boot-on;
+
+				regulator-state-mem {
+					regulator-on-in-suspend;
+					regulator-suspend-microvolt = <3300000>;
+				};
+			};
+
+			vcc_bl: LDO_REG7 {
+				regulator-name = "vcc_bl";
+				regulator-min-microvolt = <3300000>;
+				regulator-max-microvolt = <3300000>;
+
+				regulator-state-mem {
+					regulator-off-in-suspend;
+					regulator-suspend-microvolt = <3300000>;
+				};
+			};
+
+			vcc_lcd: LDO_REG8 {
+				regulator-name = "vcc_lcd";
+				regulator-min-microvolt = <2800000>;
+				regulator-max-microvolt = <2800000>;
+
+				regulator-state-mem {
+					regulator-off-in-suspend;
+					regulator-suspend-microvolt = <2800000>;
+				};
+			};
+
+			LDO_REG9 {
+				/* unused */
+			};
+
+			usb_midu: BOOST {
+				regulator-name = "usb_midu";
+				regulator-min-microvolt = <5000000>;
+				regulator-max-microvolt = <5400000>;
+				regulator-always-on;
+				regulator-boot-on;
+			};
+		};
+
+		rk817_charger: charger {
+			rockchip,resistor-sense-micro-ohms = <10000>;
+			rockchip,sleep-enter-current-microamp = <300000>;
+			rockchip,sleep-filter-current-microamp = <100000>;
+		};
+
+		rk817_codec: codec {
+			rockchip,mic-in-differential;
+		};
+	};
+};
+
+/* EXT Header(P2): 7(SCL:GPIO0.C2), 8(SDA:GPIO0.C3) */
+&i2c1 {
+	clock-frequency = <400000>;
+	status = "okay";
+};
+
+/* I2S 1 Channel Used */
+&i2s1_2ch {
+	status = "okay";
+};
+
+&io_domains {
+	vccio1-supply = <&vcc_3v3>;
+	vccio2-supply = <&vccio_sd>;
+	vccio3-supply = <&vcc_3v3>;
+	vccio4-supply = <&vcc_3v3>;
+	vccio5-supply = <&vcc_3v3>;
+	vccio6-supply = <&vcc_3v3>;
+	status = "okay";
+};
+
+&pmu_io_domains {
+	pmuio1-supply = <&vcc3v3_pmu>;
+	pmuio2-supply = <&vcc3v3_pmu>;
+	status = "okay";
+};
+
+&pwm1 {
+	status = "okay";
+};
+
+&pwm3 {
+	status = "okay";
+};
+
+&saradc {
+	vref-supply = <&vcc_1v8>;
+	status = "okay";
+};
+
+&sdmmc {
+	cap-sd-highspeed;
+	card-detect-delay = <200>;
+	cd-gpios = <&gpio0 RK_PA3 GPIO_ACTIVE_LOW>; /*[> CD GPIO <]*/
+	sd-uhs-sdr12;
+	sd-uhs-sdr25;
+	sd-uhs-sdr50;
+	sd-uhs-sdr104;
+	vmmc-supply = <&vcc_sd>;
+	vqmmc-supply = <&vccio_sd>;
+	status = "okay";
+};
+
+&sfc {
+	pinctrl-0 = <&sfc_clk &sfc_cs0 &sfc_bus2>;
+	pinctrl-names = "default";
+	#address-cells = <1>;
+	#size-cells = <0>;
+	status = "okay";
+
+	flash@0 {
+		compatible = "jedec,spi-nor";
+		reg = <0>;
+		spi-max-frequency = <108000000>;
+		spi-rx-bus-width = <2>;
+		spi-tx-bus-width = <1>;
+	};
+};
+
+&tsadc {
+	status = "okay";
+};
+
+&u2phy {
+	status = "okay";
+
+	u2phy_host: host-port {
+		status = "okay";
+	};
+
+	u2phy_otg: otg-port {
+		status = "disabled";
+	};
+};
+
+&usb20_otg {
+	status = "okay";
+};
+
+/* EXT Header(P2): 2(RXD:GPIO1.C0),3(TXD:.C1),4(CTS:.C2),5(RTS:.C3) */
+&uart1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&uart1_xfer &uart1_cts>;
+	status = "okay";
+};
+
+&uart2 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&uart2m1_xfer>;
+	status = "okay";
+};
+
+&vopb {
+	status = "okay";
+};
+
+&vopb_mmu {
+	status = "okay";
+};
+
+&pinctrl {
+	btns {
+		btn_pins: btn-pins {
+			rockchip,pins = <1 RK_PA2 RK_FUNC_GPIO &pcfg_pull_up>,
+					<1 RK_PA5 RK_FUNC_GPIO &pcfg_pull_up>,
+					<1 RK_PA6 RK_FUNC_GPIO &pcfg_pull_up>,
+					<1 RK_PA7 RK_FUNC_GPIO &pcfg_pull_up>,
+					<1 RK_PB4 RK_FUNC_GPIO &pcfg_pull_up>,
+					<1 RK_PB5 RK_FUNC_GPIO &pcfg_pull_up>,
+					<1 RK_PB6 RK_FUNC_GPIO &pcfg_pull_up>,
+					<1 RK_PB7 RK_FUNC_GPIO &pcfg_pull_up>,
+					<2 RK_PA0 RK_FUNC_GPIO &pcfg_pull_up>,
+					<2 RK_PA1 RK_FUNC_GPIO &pcfg_pull_up>,
+					<2 RK_PA2 RK_FUNC_GPIO &pcfg_pull_up>,
+					<2 RK_PA3 RK_FUNC_GPIO &pcfg_pull_up>,
+					<2 RK_PA4 RK_FUNC_GPIO &pcfg_pull_up>,
+					<2 RK_PA5 RK_FUNC_GPIO &pcfg_pull_up>,
+					<2 RK_PA6 RK_FUNC_GPIO &pcfg_pull_up>,
+					<2 RK_PA7 RK_FUNC_GPIO &pcfg_pull_up>;
+		};
+	};
+
+	headphone {
+		hp_det: hp-det {
+			rockchip,pins = <2 RK_PC6 RK_FUNC_GPIO &pcfg_pull_down>;
+		};
+	};
+
+	leds {
+		red_led_pin: red-led-pin {
+			rockchip,pins = <0 RK_PB5 RK_FUNC_GPIO &pcfg_pull_none>;
+		};
+	};
+
+	pmic {
+		dc_det: dc-det {
+			rockchip,pins = <0 RK_PB3 RK_FUNC_GPIO &pcfg_pull_none>;
+		};
+
+		pmic_int: pmic-int {
+			rockchip,pins = <0 RK_PB2 RK_FUNC_GPIO &pcfg_pull_up>;
+		};
+
+		soc_slppin_gpio: soc_slppin_gpio {
+			rockchip,pins = <0 RK_PA4 RK_FUNC_GPIO &pcfg_output_low>;
+		};
+
+		soc_slppin_rst: soc_slppin_rst {
+			rockchip,pins = <0 RK_PA4 2 &pcfg_pull_none>;
+		};
+
+		soc_slppin_slp: soc_slppin_slp {
+			rockchip,pins = <0 RK_PA4 1 &pcfg_pull_none>;
+		};
+	};
+};
diff -rupN linux.orig/arch/arm64/boot/dts/rockchip/rk3326-odroid-go2-v11.dts linux/arch/arm64/boot/dts/rockchip/rk3326-odroid-go2-v11.dts
--- linux.orig/arch/arm64/boot/dts/rockchip/rk3326-odroid-go2-v11.dts	1970-01-01 00:00:00.000000000 +0000
+++ linux/arch/arm64/boot/dts/rockchip/rk3326-odroid-go2-v11.dts	2023-10-28 04:02:49.341614140 +0000
@@ -0,0 +1,303 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Copyright (c) 2019 Hardkernel Co., Ltd
+ * Copyright (c) 2020 Theobroma Systems Design und Consulting GmbH
+ * Copyright (c) 2022 Maya Matuszczyk <maccraft123mc@gmail.com>
+ */
+
+/dts-v1/;
+#include "rk3326-odroid-go.dtsi"
+
+/ {
+	model = "ODROID-GO Advance Black Edition";
+	compatible = "hardkernel,rk3326-odroid-go2-v11", "rockchip,rk3326";
+
+	aliases {
+		mmc1 = &sdio;
+	};
+
+	gpio_keys: volume-keys {
+		compatible = "gpio-keys-polled";
+		poll-interval = <5>;
+		autorepeat;
+
+		volume-up-button {
+			label = "VOLUME-UP";
+			linux,code = <KEY_VOLUMEUP>;
+			gpios = <&gpio2 RK_PA3 GPIO_ACTIVE_LOW>;
+
+		};
+		volume-down-button {
+			label = "VOLUME-DOWN";
+			linux,code = <KEY_VOLUMEDOWN>;
+			gpios = <&gpio2 RK_PA2 GPIO_ACTIVE_LOW>;
+
+		};
+	};
+
+	joypad: odroidgo2-joypad {
+                compatible = "odroidgo2-v11-joypad";
+
+                /*
+                  - odroidgo2-joypad sysfs list -
+		   * for poll device interval(ms)
+		   /sys/devices/platform/odroidgo2_joypad/poll_interval [rw]
+                   * for button-adc-fuzz
+		   /sys/devices/platform/odroidgo2_joypad/adc_fuzz [r]
+                   * for button-adc-flat
+		   /sys/devices/platform/odroidgo2_joypad/adc_flat [r]
+
+		   * for report control(1:enable, 0:disable)
+		   /sys/devices/platform/odroidgo2_joypad/enable [rw]
+		   * for adc calibration value setup(1:current adcs value -> cal value)
+		   /sys/devices/platform/odroidgo2_joypad/adc_cal [rw]
+                */
+
+		/* gpio pincontrol setup */
+                pinctrl-names = "default";
+                pinctrl-0 = <&btn_pins>;
+
+		/* JOY_X, JOY_Y Channel define */
+		io-channel-names = "joy_x", "joy_y";
+		io-channels = <&saradc 1>, <&saradc 2>;
+
+		/* adc channel count */
+		button-adc-count = <2>;
+
+		/* adc calculate scale */
+		button-adc-scale = <2>;
+
+		/* adc deadzone range  */
+		button-adc-deadzone = <20>;
+
+		/*
+		    joy-stick voltage range
+		    /sys/devices/platform/ff288000.saradc/iio:device0
+		    adc-x : in_voltage1_raw
+		    adc-y : in_voltage2_raw
+
+		    range calculate.
+		    (adc raw max value - adc raw min value) * scale * 1.7515
+		*/
+		button-adc-x-range = <1800>;
+		button-adc-y-range = <1800>;
+
+		/*
+		  specifies fuzz value that is used to filter noise from
+		  the event stream.
+		*/
+		button-adc-fuzz = <32>;
+		button-adc-flat = <32>;
+
+		/* poll device interval (ms), adc read interval */
+		poll-interval = <10>;
+
+		/* gpio button auto repeat set value : default disable */
+		/*
+			autorepeat;
+		*/
+
+		/*
+		      *** ODROIDGO2-Advance Switch layoout ***
+		|------------------------------------------------|
+		| sw15                                      sw16 |
+		|        sw20                         sw21       |
+		|------------------------------------------------|
+		|     sw1      |-------------------|      sw8    |
+		|  sw3   sw4   |                   |   sw7   sw5 |
+		|     sw2      |    LCD Display    |      sw6    |
+		|              |                   |             |
+		|              |-------------------|             |
+		|         sw9 sw10   vol- vol+   sw13 sw14       |
+		|------------------------------------------------|
+		*/
+                /*
+                    joypad driver is poll-device driver.
+                    poll-device is does not support wakeup-source.
+		*/
+                sw1 {
+                        gpios = <&gpio1 RK_PB4 GPIO_ACTIVE_LOW>;
+                        label = "GPIO DPAD-UP";
+                        linux,code = <BTN_DPAD_UP>; // 0x220
+                };
+                sw2 {
+                        gpios = <&gpio1 RK_PB5 GPIO_ACTIVE_LOW>;
+                        label = "GPIO DPAD-DOWN";
+                        linux,code = <BTN_DPAD_DOWN>; // 0x221
+                };
+                sw3 {
+                        gpios = <&gpio1 RK_PB6 GPIO_ACTIVE_LOW>;
+                        label = "GPIO DPAD-LEFT";
+                        linux,code = <BTN_DPAD_LEFT>; // 0x222
+                };
+                sw4 {
+                        gpios = <&gpio1 RK_PB7 GPIO_ACTIVE_LOW>;
+                        label = "GPIO DPAD-RIGHT";
+                        linux,code = <BTN_DPAD_RIGHT>; // 0x223
+                };
+                sw5 {
+                        gpios = <&gpio1 RK_PA2 GPIO_ACTIVE_LOW>;
+                        label = "GPIO KEY BTN-A";
+                        linux,code = <BTN_EAST>; // 0x131
+                };
+                sw6 {
+                        gpios = <&gpio1 RK_PA5 GPIO_ACTIVE_LOW>;
+                        label = "GPIO BTN-B";
+                        linux,code = <BTN_SOUTH>; // 0x130
+                };
+                sw7 {
+                        gpios = <&gpio1 RK_PA6 GPIO_ACTIVE_LOW>;
+                        label = "GPIO BTN-Y";
+                        linux,code = <BTN_WEST>; // 0x134
+                };
+                sw8 {
+                        gpios = <&gpio1 RK_PA7 GPIO_ACTIVE_LOW>;
+                        label = "GPIO BTN-X";
+                        linux,code = <BTN_NORTH>; // 0x133
+                };
+                sw9 {
+                        gpios = <&gpio2 RK_PA0 GPIO_ACTIVE_LOW>;
+                        label = "GPIO F1";
+                        linux,code = <BTN_TRIGGER_HAPPY1>; // 0x2c0
+                };
+                sw10 {
+                        gpios = <&gpio2 RK_PA1 GPIO_ACTIVE_LOW>;
+                        label = "GPIO F2";
+                        linux,code = <BTN_TRIGGER_HAPPY2>; // 0x2c1
+                };
+                sw13 {
+                        gpios = <&gpio2 RK_PA4 GPIO_ACTIVE_LOW>;
+                        label = "GPIO F5";
+                        linux,code = <BTN_TRIGGER_HAPPY5>; // 0x2c4
+                };
+                sw14 {
+                        gpios = <&gpio2 RK_PA5 GPIO_ACTIVE_LOW>;
+                        label = "GPIO F6";
+                        linux,code = <BTN_TRIGGER_HAPPY6>; // 0x13c
+                };
+                sw15 {
+                        gpios = <&gpio2 RK_PA6 GPIO_ACTIVE_LOW>;
+                        label = "GPIO TOP-LEFT";
+                        linux,code = <BTN_TL>; // 0x02
+                };
+                sw16 {
+                        gpios = <&gpio2 RK_PA7 GPIO_ACTIVE_LOW>;
+                        label = "GPIO TOP-RIGHT";
+                        linux,code = <BTN_TR>; // 0x05
+                };
+                sw20 {
+                        gpios = <&gpio3 RK_PB7 GPIO_ACTIVE_LOW>;
+                        label = "GPIO TOP-LEFT2";
+                        linux,code = <BTN_TL2>;
+                };
+                sw21 {
+                        gpios = <&gpio3 RK_PB2 GPIO_ACTIVE_LOW>;
+                        label = "GPIO TOP-RIGHT2";
+                        linux,code = <BTN_TR2>;
+                };
+        };
+
+	battery: battery {
+		compatible = "simple-battery";
+		charge-full-design-microamp-hours = <3000000>;
+		charge-term-current-microamp = <300000>;
+		constant-charge-current-max-microamp = <2000000>;
+		constant-charge-voltage-max-microvolt = <4200000>;
+		factory-internal-resistance-micro-ohms = <180000>;
+		voltage-max-design-microvolt = <4100000>;
+		voltage-min-design-microvolt = <3500000>;
+
+		ocv-capacity-celsius = <20>;
+		ocv-capacity-table-0 =  <4046950 100>, <4001920 95>, <3967900 90>, <3919950 85>,
+					<3888450 80>, <3861850 75>, <3831540 70>, <3799130 65>,
+					<3768190 60>, <3745650 55>, <3726610 50>, <3711630 45>,
+					<3696720 40>, <3685660 35>, <3674950 30>, <3663050 25>,
+					<3649470 20>, <3635260 15>, <3616920 10>, <3592440 5>,
+					<3574170 0>;
+	};
+
+	wifi_pwrseq: wifi-pwrseq {
+		compatible = "mmc-pwrseq-simple";
+		pinctrl-names = "default";
+		pinctrl-0 = <&wifi_pwrseq_pins>;
+		reset-gpios = <&gpio3 RK_PB1 GPIO_ACTIVE_LOW>;
+		post-power-on-delay-ms = <300>;
+		power-off-delay-us = <200000>;
+	};
+};
+
+&internal_display {
+	compatible = "elida,kd35t133";
+	iovcc-supply = <&vcc_lcd>;
+	vdd-supply = <&vcc_lcd>;
+	rotation = <270>;
+};
+
+&rk817 {
+	regulators {
+		vcc_wifi: LDO_REG9 {
+			regulator-name = "vcc_wifi";
+			regulator-min-microvolt = <3300000>;
+			regulator-max-microvolt = <3300000>;
+			regulator-always-on;
+			regulator-boot-on;
+
+			regulator-state-mem {
+				regulator-off-in-suspend;
+				regulator-suspend-microvolt = <3300000>;
+			};
+		};
+	};
+};
+
+&rk817_charger {
+	monitored-battery = <&battery>;
+};
+
+&sdio {
+	bus-width = <4>;
+	cap-sd-highspeed;
+	cap-sdio-irq;
+	disable-wp;
+	keep-power-in-suspend;
+	non-removable;
+	vmmc-supply = <&vcc_wifi>;
+	mmc-pwrseq = <&wifi_pwrseq>;
+	status = "okay";
+
+	esp8089: wifi@1 {
+		compatible = "esp,esp8089";
+		reg = <1>;
+		esp,crystal-26M-en = <1>;
+	};
+};
+
+&pinctrl {
+	btns {
+		btn_pins: btn-pins {
+			rockchip,pins = <1 RK_PA2 RK_FUNC_GPIO &pcfg_pull_up>,
+					<1 RK_PA5 RK_FUNC_GPIO &pcfg_pull_up>,
+					<1 RK_PA6 RK_FUNC_GPIO &pcfg_pull_up>,
+					<1 RK_PA7 RK_FUNC_GPIO &pcfg_pull_up>,
+					<1 RK_PB4 RK_FUNC_GPIO &pcfg_pull_up>,
+					<1 RK_PB5 RK_FUNC_GPIO &pcfg_pull_up>,
+					<1 RK_PB6 RK_FUNC_GPIO &pcfg_pull_up>,
+					<1 RK_PB7 RK_FUNC_GPIO &pcfg_pull_up>,
+					<2 RK_PA0 RK_FUNC_GPIO &pcfg_pull_up>,
+					<2 RK_PA1 RK_FUNC_GPIO &pcfg_pull_up>,
+					<2 RK_PA4 RK_FUNC_GPIO &pcfg_pull_up>,
+					<2 RK_PA5 RK_FUNC_GPIO &pcfg_pull_up>,
+					<2 RK_PA6 RK_FUNC_GPIO &pcfg_pull_up>,
+					<2 RK_PA7 RK_FUNC_GPIO &pcfg_pull_up>,
+					<3 RK_PB2 RK_FUNC_GPIO &pcfg_pull_up>,
+					<3 RK_PB7 RK_FUNC_GPIO &pcfg_pull_up>;
+		};
+	};
+
+	wifi {
+		wifi_pwrseq_pins: wifi-pwrseq-pins {
+			rockchip,pins = <3 RK_PB1 RK_FUNC_GPIO &pcfg_pull_up>,
+					<3 RK_PB6 RK_FUNC_GPIO &pcfg_output_high>;
+		};
+	};
+};
diff -rupN linux.orig/arch/arm64/boot/dts/rockchip/rk3326-odroid-go2.dts linux/arch/arm64/boot/dts/rockchip/rk3326-odroid-go2.dts
--- linux.orig/arch/arm64/boot/dts/rockchip/rk3326-odroid-go2.dts	2023-10-27 21:46:01.208549984 +0000
+++ linux/arch/arm64/boot/dts/rockchip/rk3326-odroid-go2.dts	2023-10-28 04:02:49.341614140 +0000
@@ -2,55 +2,185 @@
 /*
  * Copyright (c) 2019 Hardkernel Co., Ltd
  * Copyright (c) 2020 Theobroma Systems Design und Consulting GmbH
+ * Copyright (c) 2022 Maya Matuszczyk <maccraft123mc@gmail.com>
  */
 
 /dts-v1/;
-#include <dt-bindings/gpio/gpio.h>
-#include <dt-bindings/input/input.h>
-#include <dt-bindings/pinctrl/rockchip.h>
-#include "rk3326.dtsi"
+#include "rk3326-odroid-go.dtsi"
 
 / {
 	model = "ODROID-GO Advance";
 	compatible = "hardkernel,rk3326-odroid-go2", "rockchip,rk3326";
 
-	aliases {
-		mmc0 = &sdmmc;
-	};
+        gpio_keys: volume-keys {
+                compatible = "gpio-keys-polled";
+                poll-interval = <5>;
+                autorepeat;
+
+                volume-up-button {
+                        label = "VOLUME-UP";
+                        linux,code = <KEY_VOLUMEUP>;
+                        gpios = <&gpio2 RK_PA3 GPIO_ACTIVE_LOW>;
+
+                };
+                volume-down-button {
+                        label = "VOLUME-DOWN";
+                        linux,code = <KEY_VOLUMEDOWN>;
+                        gpios = <&gpio2 RK_PA2 GPIO_ACTIVE_LOW>;
+
+                };
+        };
+
+	joypad: odroidgo2-joypad {
+                compatible = "odroidgo2-joypad";
+
+                /*
+                  - odroidgo2-joypad sysfs list -
+		   * for poll device interval(ms)
+		   /sys/devices/platform/odroidgo2_joypad/poll_interval [rw]
+                   * for button-adc-fuzz
+		   /sys/devices/platform/odroidgo2_joypad/adc_fuzz [r]
+                   * for button-adc-flat
+		   /sys/devices/platform/odroidgo2_joypad/adc_flat [r]
+
+		   * for report control(1:enable, 0:disable)
+		   /sys/devices/platform/odroidgo2_joypad/enable [rw]
+		   * for adc calibration value setup(1:current adcs value -> cal value)
+		   /sys/devices/platform/odroidgo2_joypad/adc_cal [rw]
+                */
+
+		/* gpio pincontrol setup */
+                pinctrl-names = "default";
+                pinctrl-0 = <&btn_pins>;
+
+		/* JOY_X, JOY_Y Channel define */
+		io-channel-names = "joy_x", "joy_y";
+		io-channels = <&saradc 1>, <&saradc 2>;
 
-	chosen {
-		stdout-path = "serial2:115200n8";
-	};
+		/* adc channel count */
+		button-adc-count = <2>;
 
-	adc-joystick {
-		compatible = "adc-joystick";
-		io-channels = <&saradc 1>,
-			      <&saradc 2>;
-		#address-cells = <1>;
-		#size-cells = <0>;
-
-		axis@0 {
-			reg = <0>;
-			abs-flat = <10>;
-			abs-fuzz = <10>;
-			abs-range = <172 772>;
-			linux,code = <ABS_X>;
-		};
-
-		axis@1 {
-			reg = <1>;
-			abs-flat = <10>;
-			abs-fuzz = <10>;
-			abs-range = <278 815>;
-			linux,code = <ABS_Y>;
-		};
-	};
+		/* adc calculate scale */
+		button-adc-scale = <2>;
 
-	backlight: backlight {
-		compatible = "pwm-backlight";
-		power-supply = <&vcc_bl>;
-		pwms = <&pwm1 0 25000 0>;
-	};
+		/* adc deadzone range  */
+		button-adc-deadzone = <20>;
+
+		/*
+		    joy-stick voltage range
+		    /sys/devices/platform/ff288000.saradc/iio:device0
+		    adc-x : in_voltage1_raw
+		    adc-y : in_voltage2_raw
+
+		    range calculate.
+		    (adc raw max value - adc raw min value) * scale * 1.7515
+		*/
+		button-adc-x-range = <1800>;
+		button-adc-y-range = <1800>;
+
+		/*
+		  specifies fuzz value that is used to filter noise from
+		  the event stream.
+		*/
+		button-adc-fuzz = <32>;
+		button-adc-flat = <32>;
+
+		/* poll device interval (ms), adc read interval */
+		poll-interval = <10>;
+
+		/* gpio button auto repeat set value : default disable */
+		/*
+			autorepeat;
+		*/
+
+		/*
+		      *** ODROIDGO2-Advance Switch layoout ***
+		|------------------------------------------------|
+		| sw15                                      sw16 |
+		|------------------------------------------------|
+		|     sw1      |-------------------|      sw8    |
+		|  sw3   sw4   |                   |   sw7   sw5 |
+		|     sw2      |    LCD Display    |      sw6    |
+		|              |                   |             |
+		|              |-------------------|             |
+		|         sw9 sw10   vol- vol+   sw13 sw14       |
+		|------------------------------------------------|
+		*/
+                /*
+                    joypad driver is poll-device driver.
+                    poll-device is does not support wakeup-source.
+		*/
+                sw1 {
+                        gpios = <&gpio1 RK_PB4 GPIO_ACTIVE_LOW>;
+                        label = "GPIO DPAD-UP";
+                        linux,code = <BTN_DPAD_UP>; // 0x220
+                };
+                sw2 {
+                        gpios = <&gpio1 RK_PB5 GPIO_ACTIVE_LOW>;
+                        label = "GPIO DPAD-DOWN";
+                        linux,code = <BTN_DPAD_DOWN>; // 0x221
+                };
+                sw3 {
+                        gpios = <&gpio1 RK_PB6 GPIO_ACTIVE_LOW>;
+                        label = "GPIO DPAD-LEFT";
+                        linux,code = <BTN_DPAD_LEFT>; // 0x222
+                };
+                sw4 {
+                        gpios = <&gpio1 RK_PB7 GPIO_ACTIVE_LOW>;
+                        label = "GPIO DPAD-RIGHT";
+                        linux,code = <BTN_DPAD_RIGHT>; // 0x223
+                };
+                sw5 {
+                        gpios = <&gpio1 RK_PA2 GPIO_ACTIVE_LOW>;
+                        label = "GPIO KEY BTN-A";
+                        linux,code = <BTN_EAST>; // 0x131
+                };
+                sw6 {
+                        gpios = <&gpio1 RK_PA5 GPIO_ACTIVE_LOW>;
+                        label = "GPIO BTN-B";
+                        linux,code = <BTN_SOUTH>; // 0x130
+                };
+                sw7 {
+                        gpios = <&gpio1 RK_PA6 GPIO_ACTIVE_LOW>;
+                        label = "GPIO BTN-Y";
+                        linux,code = <BTN_WEST>; // 0x134
+                };
+                sw8 {
+                        gpios = <&gpio1 RK_PA7 GPIO_ACTIVE_LOW>;
+                        label = "GPIO BTN-X";
+                        linux,code = <BTN_NORTH>; // 0x133
+                };
+                sw9 {
+                        gpios = <&gpio2 RK_PA0 GPIO_ACTIVE_LOW>;
+                        label = "GPIO F1";
+                        linux,code = <BTN_TRIGGER_HAPPY1>; // 0x2c0
+                };
+                sw10 {
+                        gpios = <&gpio2 RK_PA1 GPIO_ACTIVE_LOW>;
+                        label = "GPIO F2";
+                        linux,code = <BTN_TRIGGER_HAPPY2>; // 0x2c1
+                };
+                sw13 {
+                        gpios = <&gpio2 RK_PA4 GPIO_ACTIVE_LOW>;
+                        label = "GPIO F5";
+                        linux,code = <BTN_TRIGGER_HAPPY5>; // 0x2c4
+                };
+                sw14 {
+                        gpios = <&gpio2 RK_PA5 GPIO_ACTIVE_LOW>;
+                        label = "GPIO F6";
+                        linux,code = <BTN_TRIGGER_HAPPY6>; // 0x13c
+                };
+                sw15 {
+                        gpios = <&gpio2 RK_PA6 GPIO_ACTIVE_LOW>;
+                        label = "GPIO TOP-LEFT";
+                        linux,code = <BTN_TL>; // 0x02
+                };
+                sw16 {
+                        gpios = <&gpio2 RK_PA7 GPIO_ACTIVE_LOW>;
+                        label = "GPIO TOP-RIGHT";
+                        linux,code = <BTN_TR>; // 0x05
+                };
+        };
 
 	battery: battery {
 		compatible = "simple-battery";
@@ -63,606 +193,43 @@
 		voltage-min-design-microvolt = <3500000>;
 
 		ocv-capacity-celsius = <20>;
-		ocv-capacity-table-0 =	<4046950 100>, <4001920 95>, <3967900 90>, <3919950 85>,
+		ocv-capacity-table-0 =  <4046950 100>, <4001920 95>, <3967900 90>, <3919950 85>,
 					<3888450 80>, <3861850 75>, <3831540 70>, <3799130 65>,
 					<3768190 60>, <3745650 55>, <3726610 50>, <3711630 45>,
 					<3696720 40>, <3685660 35>, <3674950 30>, <3663050 25>,
 					<3649470 20>, <3635260 15>, <3616920 10>, <3592440 5>,
 					<3574170 0>;
 	};
-
-	gpio-keys {
-		compatible = "gpio-keys";
-		pinctrl-names = "default";
-		pinctrl-0 = <&btn_pins>;
-
-		/*
-		 *      *** ODROIDGO2-Advance Switch layout ***
-		 * |------------------------------------------------|
-		 * | sw15                                      sw16 |
-		 * |------------------------------------------------|
-		 * |     sw1      |-------------------|      sw8    |
-		 * |  sw3   sw4   |                   |   sw7   sw5 |
-		 * |     sw2      |    LCD Display    |      sw6    |
-		 * |              |                   |             |
-		 * |              |-------------------|             |
-		 * |         sw9 sw10   sw11 sw12   sw13 sw14       |
-		 * |------------------------------------------------|
-		 */
-
-		button-sw1 {
-			gpios = <&gpio1 RK_PB4 GPIO_ACTIVE_LOW>;
-			label = "DPAD-UP";
-			linux,code = <BTN_DPAD_UP>;
-		};
-		button-sw2 {
-			gpios = <&gpio1 RK_PB5 GPIO_ACTIVE_LOW>;
-			label = "DPAD-DOWN";
-			linux,code = <BTN_DPAD_DOWN>;
-		};
-		button-sw3 {
-			gpios = <&gpio1 RK_PB6 GPIO_ACTIVE_LOW>;
-			label = "DPAD-LEFT";
-			linux,code = <BTN_DPAD_LEFT>;
-		};
-		button-sw4 {
-			gpios = <&gpio1 RK_PB7 GPIO_ACTIVE_LOW>;
-			label = "DPAD-RIGHT";
-			linux,code = <BTN_DPAD_RIGHT>;
-		};
-		button-sw5 {
-			gpios = <&gpio1 RK_PA2 GPIO_ACTIVE_LOW>;
-			label = "BTN-A";
-			linux,code = <BTN_EAST>;
-		};
-		button-sw6 {
-			gpios = <&gpio1 RK_PA5 GPIO_ACTIVE_LOW>;
-			label = "BTN-B";
-			linux,code = <BTN_SOUTH>;
-		};
-		button-sw7 {
-			gpios = <&gpio1 RK_PA6 GPIO_ACTIVE_LOW>;
-			label = "BTN-Y";
-			linux,code = <BTN_WEST>;
-		};
-		button-sw8 {
-			gpios = <&gpio1 RK_PA7 GPIO_ACTIVE_LOW>;
-			label = "BTN-X";
-			linux,code = <BTN_NORTH>;
-		};
-		button-sw9 {
-			gpios = <&gpio2 RK_PA0 GPIO_ACTIVE_LOW>;
-			label = "F1";
-			linux,code = <BTN_TRIGGER_HAPPY1>;
-		};
-		button-sw10 {
-			gpios = <&gpio2 RK_PA1 GPIO_ACTIVE_LOW>;
-			label = "F2";
-			linux,code = <BTN_TRIGGER_HAPPY2>;
-		};
-		button-sw11 {
-			gpios = <&gpio2 RK_PA2 GPIO_ACTIVE_LOW>;
-			label = "F3";
-			linux,code = <BTN_TRIGGER_HAPPY3>;
-		};
-		button-sw12 {
-			gpios = <&gpio2 RK_PA3 GPIO_ACTIVE_LOW>;
-			label = "F4";
-			linux,code = <BTN_TRIGGER_HAPPY4>;
-		};
-		button-sw13 {
-			gpios = <&gpio2 RK_PA4 GPIO_ACTIVE_LOW>;
-			label = "F5";
-			linux,code = <BTN_TRIGGER_HAPPY5>;
-		};
-		button-sw14 {
-			gpios = <&gpio2 RK_PA5 GPIO_ACTIVE_LOW>;
-			label = "F6";
-			linux,code = <BTN_TRIGGER_HAPPY6>;
-		};
-		button-sw15 {
-			gpios = <&gpio2 RK_PA6 GPIO_ACTIVE_LOW>;
-			label = "TOP-LEFT";
-			linux,code = <BTN_TL>;
-		};
-		button-sw16 {
-			gpios = <&gpio2 RK_PA7 GPIO_ACTIVE_LOW>;
-			label = "TOP-RIGHT";
-			linux,code = <BTN_TR>;
-		};
-	};
-
-	leds: gpio-leds {
-		compatible = "gpio-leds";
-		pinctrl-names = "default";
-		pinctrl-0 = <&blue_led_pin>;
-
-		blue_led: led-0 {
-			label = "blue:heartbeat";
-			gpios = <&gpio0 RK_PC1 GPIO_ACTIVE_HIGH>;
-			linux,default-trigger = "heartbeat";
-		};
-	};
-
-	rk817-sound {
-		compatible = "simple-audio-card";
-		simple-audio-card,name = "Analog";
-		simple-audio-card,format = "i2s";
-		simple-audio-card,hp-det-gpio = <&gpio2 RK_PC6 GPIO_ACTIVE_HIGH>;
-		simple-audio-card,mclk-fs = <256>;
-		simple-audio-card,widgets =
-			"Microphone", "Mic Jack",
-			"Headphone", "Headphones",
-			"Speaker", "Speaker";
-		simple-audio-card,routing =
-			"MICL", "Mic Jack",
-			"Headphones", "HPOL",
-			"Headphones", "HPOR",
-			"Speaker", "SPKO";
-
-		simple-audio-card,codec {
-			sound-dai = <&rk817>;
-		};
-
-		simple-audio-card,cpu {
-			sound-dai = <&i2s1_2ch>;
-		};
-	};
-
-	vccsys: vccsys {
-		compatible = "regulator-fixed";
-		regulator-name = "vcc3v8_sys";
-		regulator-always-on;
-		regulator-min-microvolt = <3800000>;
-		regulator-max-microvolt = <3800000>;
-	};
-
-	vcc_host: vcc_host {
-		compatible = "regulator-fixed";
-		regulator-name = "vcc_host";
-		regulator-min-microvolt = <5000000>;
-		regulator-max-microvolt = <5000000>;
-
-		gpio = <&gpio0 RK_PB7 GPIO_ACTIVE_HIGH>;
-		enable-active-high;
-		regulator-always-on;
-		regulator-boot-on;
-		vin-supply = <&usb_midu>;
-	};
-};
-
-&cpu0 {
-	cpu-supply = <&vdd_arm>;
-};
-
-&cpu1 {
-	cpu-supply = <&vdd_arm>;
-};
-
-&cpu2 {
-	cpu-supply = <&vdd_arm>;
-};
-
-&cpu3 {
-	cpu-supply = <&vdd_arm>;
-};
-
-&cru {
-	assigned-clocks = <&cru PLL_NPLL>,
-		<&cru ACLK_BUS_PRE>, <&cru ACLK_PERI_PRE>,
-		<&cru HCLK_BUS_PRE>, <&cru HCLK_PERI_PRE>,
-		<&cru PCLK_BUS_PRE>, <&cru SCLK_GPU>,
-		<&cru PLL_CPLL>;
-
-	assigned-clock-rates = <1188000000>,
-		<200000000>, <200000000>,
-		<150000000>, <150000000>,
-		<100000000>, <200000000>,
-		<17000000>;
-};
-
-&display_subsystem {
-	status = "okay";
-};
-
-&dsi {
-	status = "okay";
-
-	ports {
-		mipi_out: port@1 {
-			reg = <1>;
-
-			mipi_out_panel: endpoint {
-				remote-endpoint = <&mipi_in_panel>;
-			};
-		};
-	};
-
-	panel@0 {
-		compatible = "elida,kd35t133";
-		reg = <0>;
-		backlight = <&backlight>;
-		iovcc-supply = <&vcc_lcd>;
-		reset-gpios = <&gpio3 RK_PC0 GPIO_ACTIVE_LOW>;
-		rotation = <270>;
-		vdd-supply = <&vcc_lcd>;
-
-		port {
-			mipi_in_panel: endpoint {
-				remote-endpoint = <&mipi_out_panel>;
-			};
-		};
-	};
-};
-
-&dsi_dphy {
-	status = "okay";
-};
-
-&gpu {
-	mali-supply = <&vdd_logic>;
-	status = "okay";
-};
-
-&i2c0 {
-	clock-frequency = <400000>;
-	i2c-scl-falling-time-ns = <16>;
-	i2c-scl-rising-time-ns = <280>;
-	status = "okay";
-
-	rk817: pmic@20 {
-		compatible = "rockchip,rk817";
-		reg = <0x20>;
-		interrupt-parent = <&gpio0>;
-		interrupts = <RK_PB2 IRQ_TYPE_LEVEL_LOW>;
-		clock-output-names = "rk808-clkout1", "xin32k";
-		clock-names = "mclk";
-		clocks = <&cru SCLK_I2S1_OUT>;
-		pinctrl-names = "default";
-		pinctrl-0 = <&pmic_int>, <&i2s1_2ch_mclk>;
-		wakeup-source;
-		#clock-cells = <1>;
-		#sound-dai-cells = <0>;
-
-		vcc1-supply = <&vccsys>;
-		vcc2-supply = <&vccsys>;
-		vcc3-supply = <&vccsys>;
-		vcc4-supply = <&vccsys>;
-		vcc5-supply = <&vccsys>;
-		vcc6-supply = <&vccsys>;
-		vcc7-supply = <&vccsys>;
-		vcc8-supply = <&vccsys>;
-
-		regulators {
-			vdd_logic: DCDC_REG1 {
-				regulator-name = "vdd_logic";
-				regulator-min-microvolt = <950000>;
-				regulator-max-microvolt = <1150000>;
-				regulator-ramp-delay = <6001>;
-				regulator-always-on;
-				regulator-boot-on;
-
-				regulator-state-mem {
-					regulator-on-in-suspend;
-					regulator-suspend-microvolt = <950000>;
-				};
-			};
-
-			vdd_arm: DCDC_REG2 {
-				regulator-name = "vdd_arm";
-				regulator-min-microvolt = <950000>;
-				regulator-max-microvolt = <1350000>;
-				regulator-ramp-delay = <6001>;
-				regulator-always-on;
-				regulator-boot-on;
-
-				regulator-state-mem {
-					regulator-off-in-suspend;
-					regulator-suspend-microvolt = <950000>;
-				};
-			};
-
-			vcc_ddr: DCDC_REG3 {
-				regulator-name = "vcc_ddr";
-				regulator-always-on;
-				regulator-boot-on;
-
-				regulator-state-mem {
-					regulator-on-in-suspend;
-				};
-			};
-
-			vcc_3v3: DCDC_REG4 {
-				regulator-name = "vcc_3v3";
-				regulator-min-microvolt = <3300000>;
-				regulator-max-microvolt = <3300000>;
-				regulator-always-on;
-				regulator-boot-on;
-
-				regulator-state-mem {
-					regulator-off-in-suspend;
-					regulator-suspend-microvolt = <3300000>;
-				};
-			};
-
-			vcc_1v8: LDO_REG2 {
-				regulator-name = "vcc_1v8";
-				regulator-min-microvolt = <1800000>;
-				regulator-max-microvolt = <1800000>;
-				regulator-always-on;
-				regulator-boot-on;
-
-				regulator-state-mem {
-					regulator-on-in-suspend;
-					regulator-suspend-microvolt = <1800000>;
-				};
-			};
-
-			vdd_1v0: LDO_REG3 {
-				regulator-name = "vdd_1v0";
-				regulator-min-microvolt = <1000000>;
-				regulator-max-microvolt = <1000000>;
-				regulator-always-on;
-				regulator-boot-on;
-
-				regulator-state-mem {
-					regulator-on-in-suspend;
-					regulator-suspend-microvolt = <1000000>;
-				};
-			};
-
-			vcc3v3_pmu: LDO_REG4 {
-				regulator-name = "vcc3v3_pmu";
-				regulator-min-microvolt = <3300000>;
-				regulator-max-microvolt = <3300000>;
-				regulator-always-on;
-				regulator-boot-on;
-
-				regulator-state-mem {
-					regulator-on-in-suspend;
-					regulator-suspend-microvolt = <3300000>;
-				};
-			};
-
-			vccio_sd: LDO_REG5 {
-				regulator-name = "vccio_sd";
-				regulator-min-microvolt = <1800000>;
-				regulator-max-microvolt = <3300000>;
-				regulator-always-on;
-				regulator-boot-on;
-
-				regulator-state-mem {
-					regulator-on-in-suspend;
-					regulator-suspend-microvolt = <3300000>;
-				};
-			};
-
-			vcc_sd: LDO_REG6 {
-				regulator-name = "vcc_sd";
-				regulator-min-microvolt = <3300000>;
-				regulator-max-microvolt = <3300000>;
-				regulator-boot-on;
-
-				regulator-state-mem {
-					regulator-on-in-suspend;
-					regulator-suspend-microvolt = <3300000>;
-				};
-			};
-
-			vcc_bl: LDO_REG7 {
-				regulator-name = "vcc_bl";
-				regulator-min-microvolt = <3300000>;
-				regulator-max-microvolt = <3300000>;
-
-				regulator-state-mem {
-					regulator-off-in-suspend;
-					regulator-suspend-microvolt = <3300000>;
-				};
-			};
-
-			vcc_lcd: LDO_REG8 {
-				regulator-name = "vcc_lcd";
-				regulator-min-microvolt = <2800000>;
-				regulator-max-microvolt = <2800000>;
-
-				regulator-state-mem {
-					regulator-off-in-suspend;
-					regulator-suspend-microvolt = <2800000>;
-				};
-			};
-
-			vcc_cam: LDO_REG9 {
-				regulator-name = "vcc_cam";
-				regulator-min-microvolt = <3000000>;
-				regulator-max-microvolt = <3000000>;
-
-				regulator-state-mem {
-					regulator-off-in-suspend;
-					regulator-suspend-microvolt = <3000000>;
-				};
-			};
-
-			usb_midu: BOOST {
-				regulator-name = "usb_midu";
-				regulator-min-microvolt = <5000000>;
-				regulator-max-microvolt = <5400000>;
-				regulator-always-on;
-				regulator-boot-on;
-			};
-		};
-
-		rk817_charger: charger {
-			monitored-battery = <&battery>;
-			rockchip,resistor-sense-micro-ohms = <10000>;
-			rockchip,sleep-enter-current-microamp = <300000>;
-			rockchip,sleep-filter-current-microamp = <100000>;
-		};
-
-		rk817_codec: codec {
-			rockchip,mic-in-differential;
-		};
-	};
-};
-
-/* EXT Header(P2): 7(SCL:GPIO0.C2), 8(SDA:GPIO0.C3) */
-&i2c1 {
-	clock-frequency = <400000>;
-	status = "okay";
-};
-
-/* I2S 1 Channel Used */
-&i2s1_2ch {
-	status = "okay";
-};
-
-&io_domains {
-	vccio1-supply = <&vcc_3v3>;
-	vccio2-supply = <&vccio_sd>;
-	vccio3-supply = <&vcc_3v3>;
-	vccio4-supply = <&vcc_3v3>;
-	vccio5-supply = <&vcc_3v3>;
-	vccio6-supply = <&vcc_3v3>;
-	status = "okay";
-};
-
-&pmu_io_domains {
-	pmuio1-supply = <&vcc3v3_pmu>;
-	pmuio2-supply = <&vcc3v3_pmu>;
-	status = "okay";
-};
-
-&pwm1 {
-	status = "okay";
-};
-
-&saradc {
-	vref-supply = <&vcc_1v8>;
-	status = "okay";
-};
-
-&sdmmc {
-	cap-sd-highspeed;
-	card-detect-delay = <200>;
-	cd-gpios = <&gpio0 RK_PA3 GPIO_ACTIVE_LOW>; /*[> CD GPIO <]*/
-	sd-uhs-sdr12;
-	sd-uhs-sdr25;
-	sd-uhs-sdr50;
-	sd-uhs-sdr104;
-	vmmc-supply = <&vcc_sd>;
-	vqmmc-supply = <&vccio_sd>;
-	status = "okay";
-};
-
-&sfc {
-	pinctrl-0 = <&sfc_clk &sfc_cs0 &sfc_bus2>;
-	pinctrl-names = "default";
-	#address-cells = <1>;
-	#size-cells = <0>;
-	status = "okay";
-
-	flash@0 {
-		compatible = "jedec,spi-nor";
-		reg = <0>;
-		spi-max-frequency = <108000000>;
-		spi-rx-bus-width = <2>;
-		spi-tx-bus-width = <1>;
-	};
-};
-
-&tsadc {
-	status = "okay";
-};
-
-&u2phy {
-	status = "okay";
-
-	u2phy_host: host-port {
-		status = "okay";
-	};
-
-	u2phy_otg: otg-port {
-		status = "disabled";
-	};
-};
-
-&usb20_otg {
-	status = "okay";
 };
 
-/* EXT Header(P2): 2(RXD:GPIO1.C0),3(TXD:.C1),4(CTS:.C2),5(RTS:.C3) */
-&uart1 {
-	pinctrl-names = "default";
-	pinctrl-0 = <&uart1_xfer &uart1_cts>;
-	status = "okay";
+&internal_display {
+	compatible = "elida,kd35t133";
+	iovcc-supply = <&vcc_lcd>;
+	vdd-supply = <&vcc_lcd>;
+	rotation = <270>;
 };
 
-&uart2 {
-	pinctrl-names = "default";
-	pinctrl-0 = <&uart2m1_xfer>;
-	status = "okay";
-};
-
-&vopb {
-	status = "okay";
-};
-
-&vopb_mmu {
-	status = "okay";
+&rk817_charger {
+	monitored-battery = <&battery>;
 };
 
 &pinctrl {
-	btns {
-		btn_pins: btn-pins {
-			rockchip,pins = <1 RK_PA2 RK_FUNC_GPIO &pcfg_pull_up>,
-					<1 RK_PA5 RK_FUNC_GPIO &pcfg_pull_up>,
-					<1 RK_PA6 RK_FUNC_GPIO &pcfg_pull_up>,
-					<1 RK_PA7 RK_FUNC_GPIO &pcfg_pull_up>,
-					<1 RK_PB4 RK_FUNC_GPIO &pcfg_pull_up>,
-					<1 RK_PB5 RK_FUNC_GPIO &pcfg_pull_up>,
-					<1 RK_PB6 RK_FUNC_GPIO &pcfg_pull_up>,
-					<1 RK_PB7 RK_FUNC_GPIO &pcfg_pull_up>,
-					<2 RK_PA0 RK_FUNC_GPIO &pcfg_pull_up>,
-					<2 RK_PA1 RK_FUNC_GPIO &pcfg_pull_up>,
-					<2 RK_PA2 RK_FUNC_GPIO &pcfg_pull_up>,
-					<2 RK_PA3 RK_FUNC_GPIO &pcfg_pull_up>,
-					<2 RK_PA4 RK_FUNC_GPIO &pcfg_pull_up>,
-					<2 RK_PA5 RK_FUNC_GPIO &pcfg_pull_up>,
-					<2 RK_PA6 RK_FUNC_GPIO &pcfg_pull_up>,
-					<2 RK_PA7 RK_FUNC_GPIO &pcfg_pull_up>;
-		};
-	};
-
-	headphone {
-		hp_det: hp-det {
-			rockchip,pins = <2 RK_PC6 RK_FUNC_GPIO &pcfg_pull_down>;
-		};
-	};
-
-	leds {
-		blue_led_pin: blue-led-pin {
-			rockchip,pins = <0 RK_PC1 RK_FUNC_GPIO &pcfg_pull_none>;
-		};
-	};
-
-	pmic {
-		dc_det: dc-det {
-			rockchip,pins = <0 RK_PB3 RK_FUNC_GPIO &pcfg_pull_none>;
-		};
-
-		pmic_int: pmic-int {
-			rockchip,pins = <0 RK_PB2 RK_FUNC_GPIO &pcfg_pull_up>;
-		};
-
-		soc_slppin_gpio: soc_slppin_gpio {
-			rockchip,pins = <0 RK_PA4 RK_FUNC_GPIO &pcfg_output_low>;
-		};
-
-		soc_slppin_rst: soc_slppin_rst {
-			rockchip,pins = <0 RK_PA4 2 &pcfg_pull_none>;
-		};
-
-		soc_slppin_slp: soc_slppin_slp {
-			rockchip,pins = <0 RK_PA4 1 &pcfg_pull_none>;
-		};
-	};
+        btns {
+                btn_pins: btn-pins {
+                        rockchip,pins = <1 RK_PA2 RK_FUNC_GPIO &pcfg_pull_up>,
+                                        <1 RK_PA5 RK_FUNC_GPIO &pcfg_pull_up>,
+                                        <1 RK_PA6 RK_FUNC_GPIO &pcfg_pull_up>,
+                                        <1 RK_PA7 RK_FUNC_GPIO &pcfg_pull_up>,
+                                        <1 RK_PB4 RK_FUNC_GPIO &pcfg_pull_up>,
+                                        <1 RK_PB5 RK_FUNC_GPIO &pcfg_pull_up>,
+                                        <1 RK_PB6 RK_FUNC_GPIO &pcfg_pull_up>,
+                                        <1 RK_PB7 RK_FUNC_GPIO &pcfg_pull_up>,
+                                        <2 RK_PA0 RK_FUNC_GPIO &pcfg_pull_up>,
+                                        <2 RK_PA1 RK_FUNC_GPIO &pcfg_pull_up>,
+                                        <2 RK_PA4 RK_FUNC_GPIO &pcfg_pull_up>,
+                                        <2 RK_PA5 RK_FUNC_GPIO &pcfg_pull_up>,
+                                        <2 RK_PA6 RK_FUNC_GPIO &pcfg_pull_up>,
+                                        <2 RK_PA7 RK_FUNC_GPIO &pcfg_pull_up>;
+                };
+        };
 };
diff -rupN linux.orig/arch/arm64/boot/dts/rockchip/rk3326-odroid-go3.dts linux/arch/arm64/boot/dts/rockchip/rk3326-odroid-go3.dts
--- linux.orig/arch/arm64/boot/dts/rockchip/rk3326-odroid-go3.dts	1970-01-01 00:00:00.000000000 +0000
+++ linux/arch/arm64/boot/dts/rockchip/rk3326-odroid-go3.dts	2023-10-28 04:02:49.341614140 +0000
@@ -0,0 +1,284 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Copyright (c) 2019 Hardkernel Co., Ltd
+ * Copyright (c) 2020 Theobroma Systems Design und Consulting GmbH
+ * Copyright (c) 2022 Maya Matuszczyk <maccraft123mc@gmail.com>
+ */
+
+/dts-v1/;
+#include "rk3326-odroid-go.dtsi"
+
+/ {
+	model = "ODROID-GO Super";
+	compatible = "hardkernel,rk3326-odroid-go3", "rockchip,rk3326";
+
+	joypad: odroidgo3-joypad {
+        compatible = "odroidgo3-joypad";
+		status = "okay";
+                /*
+                  - odroidgo3-joypad sysfs list -
+		   * for poll device interval(ms)
+		   /sys/devices/platform/odroidgo3_joypad/poll_interval [rw]
+		   ex) echo 20 > poll_interval
+                   * for button-adc-fuzz
+		   /sys/devices/platform/odroidgo3_joypad/adc_fuzz [r]
+                   * for button-adc-flat
+		   /sys/devices/platform/odroidgo3_joypad/adc_flat [r]
+
+		   * for report control(1:enable, 0:disable)
+		   /sys/devices/platform/odroidgo3_joypad/enable [rw]
+		   * for adc calibration value setup(current adcs value -> cal value)
+		   /sys/devices/platform/odroidgo3_joypad/adc_cal [rw]
+		   ex) echo 0 > adc_cal
+		   * for amux data debug
+		   * Joypad driver is disabled when using this sysfs.
+		   /sys/devices/platform/odroidgo3_joypad/amux_debug [rw]
+		   ex) echo 0 > amux_debug --> select amux channel
+		   ex) cat amux_debug --> get adc data of seleted channel
+                */
+
+		/* gpio pincontrol setup */
+                pinctrl-names = "default";
+                pinctrl-0 = <&btn_pins>;
+
+		/* Analog mux define */
+		io-channel-names = "amux_adc";
+		io-channels = <&saradc 1>;
+
+		/* adc mux channel count */
+		amux-count = <4>;
+		/* adc mux select(a,b) gpio */
+		amux-a-gpios = <&gpio3 RK_PB3 GPIO_ACTIVE_LOW>;
+		amux-b-gpios = <&gpio3 RK_PB0 GPIO_ACTIVE_LOW>;
+		/* adc mux enable gpio */
+		amux-en-gpios = <&gpio3 RK_PB5 GPIO_ACTIVE_LOW>;
+
+		/* adc calculate scale */
+		button-adc-scale = <2>;
+
+		/* adc deadzone range  */
+		button-adc-deadzone = <64>;
+
+		/*
+		  specifies fuzz value that is used to filter noise from
+		  the event stream.
+		*/
+		button-adc-fuzz = <32>;
+		button-adc-flat = <32>;
+
+		/*
+		  Analog Stick data tuning value(precent)
+		  p = positive direction, n = negative direction
+		  report value = (real_adc_data * tuning_value) / 100
+		*/
+		abs_x-p-tuning = <180>;
+		abs_x-n-tuning = <180>;
+
+		abs_y-p-tuning = <180>;
+		abs_y-n-tuning = <170>;
+
+		abs_rx-p-tuning = <180>;
+		abs_rx-n-tuning = <180>;
+
+		abs_ry-p-tuning = <180>;
+		abs_ry-n-tuning = <170>;
+
+		/* poll device interval (ms), adc read interval */
+		poll-interval = <10>;
+
+		/* gpio button auto repeat set value : default disable */
+		/*
+			autorepeat;
+		*/
+
+		/*
+		      *** ODROIDGO3-Advance Switch layoout ***
+		|------------------------------------------------|
+		| sw15  sw21        sw10   sw9        sw20  sw16 |
+		|------------------------------------------------|
+		|      sw19                            sw22      |
+		|              |-------------------|             |
+		|     sw1      |                   |      sw8    |
+		|  sw3   sw4   |                   |   sw7   sw5 |
+		|     sw2      |    LCD Display    |      sw6    |
+		|              |                   |             |
+		|              |                   |             |
+		|              |-------------------|             |
+		|  sw11 sw12        | sd-slot |       sw13 sw14  |
+		|-------------------|         |------------------|
+		*/
+                /*
+                    joypad driver is poll-device driver.
+                    poll-device is does not support wakeup-source.
+		*/
+                sw1 {
+                        gpios = <&gpio1 RK_PB4 GPIO_ACTIVE_LOW>;
+                        label = "GPIO DPAD-UP";
+                        linux,code = <BTN_DPAD_UP>; // 0x220
+                };
+                sw2 {
+                        gpios = <&gpio1 RK_PB5 GPIO_ACTIVE_LOW>;
+                        label = "GPIO DPAD-DOWN";
+                        linux,code = <BTN_DPAD_DOWN>; // 0x221
+                };
+                sw3 {
+                        gpios = <&gpio1 RK_PB6 GPIO_ACTIVE_LOW>;
+                        label = "GPIO DPAD-LEFT";
+                        linux,code = <BTN_DPAD_LEFT>; // 0x222
+                };
+                sw4 {
+                        gpios = <&gpio1 RK_PB7 GPIO_ACTIVE_LOW>;
+                        label = "GPIO DPAD-RIGHT";
+                        linux,code = <BTN_DPAD_RIGHT>; // 0x223
+                };
+                sw5 {
+                        gpios = <&gpio1 RK_PA2 GPIO_ACTIVE_LOW>;
+                        label = "GPIO KEY BTN-A";
+                        linux,code = <BTN_EAST>; // 0x131
+                };
+                sw6 {
+                        gpios = <&gpio1 RK_PA5 GPIO_ACTIVE_LOW>;
+                        label = "GPIO BTN-B";
+                        linux,code = <BTN_SOUTH>; // 0x130
+                };
+                sw7 {
+                        gpios = <&gpio1 RK_PA6 GPIO_ACTIVE_LOW>;
+                        label = "GPIO BTN-Y";
+                        linux,code = <BTN_WEST>; // 0x134
+                };
+                sw8 {
+                        gpios = <&gpio1 RK_PA7 GPIO_ACTIVE_LOW>;
+                        label = "GPIO BTN-X";
+                        linux,code = <BTN_NORTH>; // 0x133
+                };
+                sw11 {
+                        gpios = <&gpio2 RK_PA2 GPIO_ACTIVE_LOW>;
+                        label = "GPIO F3";
+                        linux,code = <BTN_TRIGGER_HAPPY3>; // 0x2c2
+                };
+                sw12 {
+                        gpios = <&gpio2 RK_PA3 GPIO_ACTIVE_LOW>;
+                        label = "GPIO F4";
+                        linux,code = <BTN_TRIGGER_HAPPY4>; // 0x2c3
+                };
+                sw13 {
+                        gpios = <&gpio2 RK_PA4 GPIO_ACTIVE_LOW>;
+                        label = "GPIO F5";
+                        linux,code = <BTN_TRIGGER_HAPPY5>; // 0x2c4
+                };
+                sw14 {
+                        gpios = <&gpio2 RK_PA5 GPIO_ACTIVE_LOW>;
+                        label = "GPIO F6";
+                        linux,code = <BTN_TRIGGER_HAPPY6>; // 0x13c
+                };
+                sw15 {
+                        gpios = <&gpio2 RK_PA6 GPIO_ACTIVE_LOW>;
+                        label = "GPIO TOP-LEFT";
+                        linux,code = <BTN_TL>; // 0x02
+                };
+                sw16 {
+                        gpios = <&gpio2 RK_PA7 GPIO_ACTIVE_LOW>;
+                        label = "GPIO TOP-RIGHT";
+                        linux,code = <BTN_TR>; // 0x05
+                };
+                sw19 {
+                        gpios = <&gpio3 RK_PB1 GPIO_ACTIVE_LOW>;
+                        label = "GPIO F1";
+                        linux,code = <BTN_TRIGGER_HAPPY1>;
+                };
+                sw20 {
+                        gpios = <&gpio3 RK_PB7 GPIO_ACTIVE_LOW>;
+                        label = "GPIO TOP-RIGHT2";
+                        linux,code = <BTN_TR2>;
+                };
+                sw21 {
+                        gpios = <&gpio3 RK_PB2 GPIO_ACTIVE_LOW>;
+                        label = "GPIO TOP-LEFT2";
+                        linux,code = <BTN_TL2>;
+                };
+                sw22 {
+                        gpios = <&gpio3 RK_PB4 GPIO_ACTIVE_LOW>;
+                        label = "GPIO F2";
+                        linux,code = <BTN_TRIGGER_HAPPY2>;
+                };
+        };
+
+	battery: battery {
+		compatible = "simple-battery";
+		charge-full-design-microamp-hours = <4000000>;
+		charge-term-current-microamp = <300000>;
+		constant-charge-current-max-microamp = <2000000>;
+		constant-charge-voltage-max-microvolt = <4200000>;
+		factory-internal-resistance-micro-ohms = <180000>;
+		voltage-max-design-microvolt = <4100000>;
+		voltage-min-design-microvolt = <3500000>;
+
+		ocv-capacity-celsius = <20>;
+		ocv-capacity-table-0 =  <4046950 100>, <4001920 95>, <3967900 90>, <3919950 85>,
+					<3888450 80>, <3861850 75>, <3831540 70>, <3799130 65>,
+					<3768190 60>, <3745650 55>, <3726610 50>, <3711630 45>,
+					<3696720 40>, <3685660 35>, <3674950 30>, <3663050 25>,
+					<3649470 20>, <3635260 15>, <3616920 10>, <3592440 5>,
+					<3574170 0>;
+	};
+
+	gpio-keys-vol {
+		compatible = "gpio-keys";
+		autorepeat;
+		pinctrl-0 = <&btn_pins_vol>;
+		pinctrl-names = "default";
+
+		button-vol-down {
+			gpios = <&gpio2 RK_PA1 GPIO_ACTIVE_LOW>;
+			label = "VOLUMEDOWN";
+			linux,code = <KEY_VOLUMEDOWN>;
+		};
+
+		button-volume-up {
+			gpios = <&gpio2 RK_PA0 GPIO_ACTIVE_LOW>;
+			label = "VOLUMEUP";
+			linux,code = <KEY_VOLUMEUP>;
+		};
+	};
+};
+
+&internal_display {
+	compatible = "elida,kd50t048a", "sitronix,st7701";
+	reset-gpios = <&gpio3 RK_PC0 GPIO_ACTIVE_HIGH>;
+	IOVCC-supply = <&vcc_lcd>;
+	VCC-supply = <&vcc_lcd>;
+	rotation = <270>;
+};
+
+&rk817_charger {
+	monitored-battery = <&battery>;
+};
+
+&pinctrl {
+	btns {
+		btn_pins: btn-pins {
+			rockchip,pins = <1 RK_PA2 RK_FUNC_GPIO &pcfg_pull_up>,
+					<1 RK_PA5 RK_FUNC_GPIO &pcfg_pull_up>,
+					<1 RK_PA6 RK_FUNC_GPIO &pcfg_pull_up>,
+					<1 RK_PA7 RK_FUNC_GPIO &pcfg_pull_up>,
+					<1 RK_PB4 RK_FUNC_GPIO &pcfg_pull_up>,
+					<1 RK_PB5 RK_FUNC_GPIO &pcfg_pull_up>,
+					<1 RK_PB6 RK_FUNC_GPIO &pcfg_pull_up>,
+					<1 RK_PB7 RK_FUNC_GPIO &pcfg_pull_up>,
+					<2 RK_PA2 RK_FUNC_GPIO &pcfg_pull_up>,
+					<2 RK_PA3 RK_FUNC_GPIO &pcfg_pull_up>,
+					<2 RK_PA4 RK_FUNC_GPIO &pcfg_pull_up>,
+					<2 RK_PA5 RK_FUNC_GPIO &pcfg_pull_up>,
+					<2 RK_PA6 RK_FUNC_GPIO &pcfg_pull_up>,
+					<2 RK_PA7 RK_FUNC_GPIO &pcfg_pull_up>,
+					<3 RK_PB1 RK_FUNC_GPIO &pcfg_pull_up>,
+					<3 RK_PB2 RK_FUNC_GPIO &pcfg_pull_up>,
+					<3 RK_PB4 RK_FUNC_GPIO &pcfg_pull_up>,
+					<3 RK_PB7 RK_FUNC_GPIO &pcfg_pull_up>;
+		};
+		btn_pins_vol: btn-pins-vol {
+			rockchip,pins = <2 RK_PA0 RK_FUNC_GPIO &pcfg_pull_up>,
+					<2 RK_PA1 RK_FUNC_GPIO &pcfg_pull_up>;
+		};
+	};
+};
diff -rupN linux.orig/drivers/devfreq/Kconfig linux/drivers/devfreq/Kconfig
--- linux.orig/drivers/devfreq/Kconfig	2023-10-27 21:46:01.712562721 +0000
+++ linux/drivers/devfreq/Kconfig	2023-10-28 04:02:49.341614140 +0000
@@ -142,6 +142,12 @@ config ARM_RK3399_DMC_DEVFREQ
 	  It sets the frequency for the memory controller and reads the usage counts
 	  from hardware.
 
+config ARM_ROCKCHIP_BUS_DEVFREQ
+	tristate "rockchip bus"
+	depends on ARCH_ROCKCHIP
+	help
+	  rk bus driver
+
 config ARM_SUN8I_A33_MBUS_DEVFREQ
 	tristate "sun8i/sun50i MBUS DEVFREQ Driver"
 	depends on ARCH_SUNXI || COMPILE_TEST
diff -rupN linux.orig/drivers/devfreq/Makefile linux/drivers/devfreq/Makefile
--- linux.orig/drivers/devfreq/Makefile	2023-10-27 21:46:01.712562721 +0000
+++ linux/drivers/devfreq/Makefile	2023-10-28 04:02:49.341614140 +0000
@@ -13,6 +13,7 @@ obj-$(CONFIG_ARM_IMX_BUS_DEVFREQ)	+= imx
 obj-$(CONFIG_ARM_IMX8M_DDRC_DEVFREQ)	+= imx8m-ddrc.o
 obj-$(CONFIG_ARM_MEDIATEK_CCI_DEVFREQ)	+= mtk-cci-devfreq.o
 obj-$(CONFIG_ARM_RK3399_DMC_DEVFREQ)	+= rk3399_dmc.o
+obj-$(CONFIG_ARM_ROCKCHIP_BUS_DEVFREQ)	+= rockchip_bus.o
 obj-$(CONFIG_ARM_SUN8I_A33_MBUS_DEVFREQ)	+= sun8i-a33-mbus.o
 obj-$(CONFIG_ARM_TEGRA_DEVFREQ)		+= tegra30-devfreq.o
 
diff -rupN linux.orig/drivers/devfreq/rockchip_bus.c linux/drivers/devfreq/rockchip_bus.c
--- linux.orig/drivers/devfreq/rockchip_bus.c	1970-01-01 00:00:00.000000000 +0000
+++ linux/drivers/devfreq/rockchip_bus.c	2023-10-28 04:02:49.341614140 +0000
@@ -0,0 +1,258 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2018, Fuzhou Rockchip Electronics Co., Ltd.
+ * Author: Tony Xie <tony.xie@rock-chips.com>
+ */
+
+#include <linux/arm-smccc.h>
+#include <linux/clk.h>
+#include <linux/cpufreq.h>
+#include <linux/delay.h>
+#include <linux/devfreq.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/pm_opp.h>
+#include <linux/platform_device.h>
+#include <linux/regulator/consumer.h>
+#include <linux/slab.h>
+#include <linux/string.h>
+
+#define CLUSTER0	0
+#define CLUSTER1	1
+#define MAX_CLUSTERS	2
+
+#define to_rockchip_bus_clk_nb(nb) \
+	container_of(nb, struct rockchip_bus, clk_nb)
+#define to_rockchip_bus_cpufreq_nb(nb) \
+	container_of(nb, struct rockchip_bus, cpufreq_nb)
+
+struct busfreq_table {
+	unsigned long freq;
+	unsigned long volt;
+};
+
+struct rockchip_bus {
+	struct device *dev;
+	struct regulator *regulator;
+	struct clk *clk;
+	struct notifier_block clk_nb;
+	struct notifier_block cpufreq_nb;
+	struct busfreq_table *freq_table;
+
+	unsigned int max_state;
+
+	unsigned long cur_volt;
+	unsigned long cur_rate;
+
+	/*
+	 * Busfreq-policy-cpufreq:
+	 * If the cpu frequency of two clusters are both less than or equal to
+	 * cpu_high_freq, change bus rate to low_rate, otherwise change it to
+	 * high_rate.
+	 */
+	unsigned long high_rate;
+	unsigned long low_rate;
+	unsigned int cpu_high_freq;
+	unsigned int cpu_freq[MAX_CLUSTERS];
+};
+
+static int rockchip_bus_set_freq_table(struct rockchip_bus *bus)
+{
+	struct device *dev = bus->dev;
+	struct dev_pm_opp *opp;
+	unsigned long freq;
+	int i, count;
+
+	count = dev_pm_opp_get_opp_count(dev);
+	if (count <= 0)
+		return -EINVAL;
+
+	bus->max_state = count;
+	bus->freq_table = devm_kcalloc(dev,
+				       bus->max_state,
+				       sizeof(*bus->freq_table),
+				       GFP_KERNEL);
+	if (!bus->freq_table) {
+		bus->max_state = 0;
+		return -ENOMEM;
+	}
+
+	for (i = 0, freq = 0; i < bus->max_state; i++, freq++) {
+		opp = dev_pm_opp_find_freq_ceil(dev, &freq);
+		if (IS_ERR(opp)) {
+			devm_kfree(dev, bus->freq_table);
+			bus->max_state = 0;
+			return PTR_ERR(opp);
+		}
+		bus->freq_table[i].volt = dev_pm_opp_get_voltage(opp);
+		bus->freq_table[i].freq = freq;
+		dev_pm_opp_put(opp);
+	}
+
+	return 0;
+}
+
+static int rockchip_bus_power_control_init(struct rockchip_bus *bus)
+{
+	struct device *dev = bus->dev;
+	int ret = 0;
+
+	bus->clk = devm_clk_get(dev, "bus");
+	if (IS_ERR(bus->clk)) {
+		dev_err(dev, "failed to get bus clock\n");
+		return PTR_ERR(bus->clk);
+	}
+
+	bus->regulator = devm_regulator_get(dev, "bus");
+	if (IS_ERR(bus->regulator)) {
+		dev_err(dev, "failed to get bus regulator\n");
+		return PTR_ERR(bus->regulator);
+	}
+
+	ret = dev_pm_opp_of_add_table(dev);
+	if (ret < 0) {
+		dev_err(dev, "failed to get OPP table\n");
+		return ret;
+	}
+
+	ret = rockchip_bus_set_freq_table(bus);
+	if (ret < 0) {
+		dev_err(dev, "failed to set bus freq table\n");
+		return ret;
+	}
+
+	return 0;
+}
+
+static int rockchip_bus_clkfreq_target(struct device *dev, unsigned long freq)
+{
+	struct rockchip_bus *bus = dev_get_drvdata(dev);
+	unsigned long target_volt = bus->freq_table[bus->max_state - 1].volt;
+	int i;
+
+	for (i = 0; i < bus->max_state; i++) {
+		if (freq <= bus->freq_table[i].freq) {
+			target_volt = bus->freq_table[i].volt;
+			break;
+		}
+	}
+
+	printk("AAA target_volt: %lu\n", target_volt);
+
+	if (bus->cur_volt != target_volt) {
+		if (regulator_set_voltage(bus->regulator, target_volt,
+					  INT_MAX)) {
+			dev_err(dev, "failed to set voltage %lu uV\n",
+				target_volt);
+			return -EINVAL;
+		}
+		bus->cur_volt = target_volt;
+	}
+
+	return 0;
+}
+
+static int rockchip_bus_clk_notifier(struct notifier_block *nb,
+				     unsigned long event, void *data)
+{
+	struct clk_notifier_data *ndata = data;
+	struct rockchip_bus *bus = to_rockchip_bus_clk_nb(nb);
+	int ret = 0;
+
+	printk("AAA event %lu, old_rate %lu, new_rate: %lu\n",
+		event, ndata->old_rate, ndata->new_rate);
+
+	switch (event) {
+	case PRE_RATE_CHANGE:
+		if (ndata->new_rate > ndata->old_rate)
+			ret = rockchip_bus_clkfreq_target(bus->dev,
+							  ndata->new_rate);
+		break;
+	case POST_RATE_CHANGE:
+		if (ndata->new_rate < ndata->old_rate)
+			ret = rockchip_bus_clkfreq_target(bus->dev,
+							  ndata->new_rate);
+		break;
+	case ABORT_RATE_CHANGE:
+		if (ndata->new_rate > ndata->old_rate)
+			ret = rockchip_bus_clkfreq_target(bus->dev,
+							  ndata->old_rate);
+		break;
+	default:
+		break;
+	}
+
+	return notifier_from_errno(ret);
+}
+
+static int rockchip_bus_clkfreq(struct rockchip_bus *bus)
+{
+	struct device *dev = bus->dev;
+	unsigned long init_rate;
+	int ret = 0;
+
+	ret = rockchip_bus_power_control_init(bus);
+	if (ret) {
+		dev_err(dev, "failed to init power control\n");
+		return ret;
+	}
+
+	init_rate = clk_get_rate(bus->clk);
+	printk("init rate %d", init_rate);
+	ret = rockchip_bus_clkfreq_target(dev, init_rate);
+	if (ret)
+		return ret;
+
+	bus->clk_nb.notifier_call = rockchip_bus_clk_notifier;
+	ret = clk_notifier_register(bus->clk, &bus->clk_nb);
+	if (ret) {
+		dev_err(dev, "failed to register clock notifier\n");
+		return ret;
+	}
+
+	return 0;
+}
+
+static const struct of_device_id rockchip_busfreq_of_match[] = {
+	{ .compatible = "rockchip,px30-bus", },
+	{ .compatible = "rockchip,rk1808-bus", },
+	{ .compatible = "rockchip,rk3288-bus", },
+	{ .compatible = "rockchip,rk3368-bus", },
+	{ .compatible = "rockchip,rk3399-bus", },
+	{ .compatible = "rockchip,rv1126-bus", },
+	{ },
+};
+
+MODULE_DEVICE_TABLE(of, rockchip_busfreq_of_match);
+
+static int rockchip_busfreq_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct device_node *np = dev->of_node;
+	struct rockchip_bus *bus;
+	const char *policy_name;
+	int ret = 0;
+
+	bus = devm_kzalloc(dev, sizeof(*bus), GFP_KERNEL);
+	if (!bus)
+		return -ENOMEM;
+	bus->dev = dev;
+	platform_set_drvdata(pdev, bus);
+
+	printk("asdfsadfsadffasdafsdhjfsdakasdfjfjasdklsfadkljsdfajklfsadjklfasdjklhasfdhjklafsdhkjsfdajkhfasdk");
+	return rockchip_bus_clkfreq(bus);
+}
+
+static struct platform_driver rockchip_busfreq_driver = {
+	.probe	= rockchip_busfreq_probe,
+	.driver = {
+		.name	= "rockchip-busfreq",
+		.of_match_table = rockchip_busfreq_of_match,
+	},
+};
+
+module_platform_driver(rockchip_busfreq_driver);
+
+MODULE_LICENSE("GPL v2");
+MODULE_AUTHOR("Tony Xie <tony.xie@rock-chips.com>");
+MODULE_DESCRIPTION("rockchip busfreq driver with devfreq framework");
diff -rupN linux.orig/drivers/gpu/drm/panel/Kconfig linux/drivers/gpu/drm/panel/Kconfig
--- linux.orig/drivers/gpu/drm/panel/Kconfig	2023-10-27 21:46:02.268576773 +0000
+++ linux/drivers/gpu/drm/panel/Kconfig	2023-10-28 04:02:49.341614140 +0000
@@ -296,6 +296,15 @@ config DRM_PANEL_NEC_NL8048HL11
 	  panel (found on the Zoom2/3/3630 SDP boards). To compile this driver
 	  as a module, choose M here.
 
+config DRM_PANEL_NEWVISION_NV3051D
+	tristate "NewVision NV3051D DSI panel"
+	depends on OF
+	depends on DRM_MIPI_DSI
+	depends on BACKLIGHT_CLASS_DEVICE
+	help
+	  This driver supports the NV3051D based panel found on the Anbernic
+	  RG353P and RG353V.
+
 config DRM_PANEL_NEWVISION_NV3052C
 	tristate "NewVision NV3052C RGB/SPI panel"
 	depends on OF && SPI
diff -rupN linux.orig/drivers/gpu/drm/panel/Makefile linux/drivers/gpu/drm/panel/Makefile
--- linux.orig/drivers/gpu/drm/panel/Makefile	2023-10-27 21:46:02.268576773 +0000
+++ linux/drivers/gpu/drm/panel/Makefile	2023-10-28 04:02:49.341614140 +0000
@@ -27,6 +27,7 @@ obj-$(CONFIG_DRM_PANEL_LEADTEK_LTK500HD1
 obj-$(CONFIG_DRM_PANEL_LG_LB035Q02) += panel-lg-lb035q02.o
 obj-$(CONFIG_DRM_PANEL_LG_LG4573) += panel-lg-lg4573.o
 obj-$(CONFIG_DRM_PANEL_NEC_NL8048HL11) += panel-nec-nl8048hl11.o
+obj-$(CONFIG_DRM_PANEL_NEWVISION_NV3051D) += panel-newvision-nv3051d.o
 obj-$(CONFIG_DRM_PANEL_NEWVISION_NV3052C) += panel-newvision-nv3052c.o
 obj-$(CONFIG_DRM_PANEL_NOVATEK_NT35510) += panel-novatek-nt35510.o
 obj-$(CONFIG_DRM_PANEL_NOVATEK_NT35560) += panel-novatek-nt35560.o
diff -rupN linux.orig/drivers/gpu/drm/panel/panel-elida-kd35t133.c linux/drivers/gpu/drm/panel/panel-elida-kd35t133.c
--- linux.orig/drivers/gpu/drm/panel/panel-elida-kd35t133.c	2023-10-27 21:46:02.272576875 +0000
+++ linux/drivers/gpu/drm/panel/panel-elida-kd35t133.c	2023-10-28 04:03:32.770593063 +0000
@@ -51,14 +51,6 @@ static inline struct kd35t133 *panel_to_
 	return container_of(panel, struct kd35t133, panel);
 }
 
-#define dsi_dcs_write_seq(dsi, cmd, seq...) do {			\
-		static const u8 b[] = { cmd, seq };			\
-		int ret;						\
-		ret = mipi_dsi_dcs_write_buffer(dsi, b, ARRAY_SIZE(b));	\
-		if (ret < 0)						\
-			return ret;					\
-	} while (0)
-
 static int kd35t133_init_sequence(struct kd35t133 *ctx)
 {
 	struct mipi_dsi_device *dsi = to_mipi_dsi_device(ctx->dev);
@@ -68,25 +60,25 @@ static int kd35t133_init_sequence(struct
 	 * Init sequence was supplied by the panel vendor with minimal
 	 * documentation.
 	 */
-	dsi_dcs_write_seq(dsi, KD35T133_CMD_POSITIVEGAMMA,
-			  0x00, 0x13, 0x18, 0x04, 0x0f, 0x06, 0x3a, 0x56,
-			  0x4d, 0x03, 0x0a, 0x06, 0x30, 0x3e, 0x0f);
-	dsi_dcs_write_seq(dsi, KD35T133_CMD_NEGATIVEGAMMA,
-			  0x00, 0x13, 0x18, 0x01, 0x11, 0x06, 0x38, 0x34,
-			  0x4d, 0x06, 0x0d, 0x0b, 0x31, 0x37, 0x0f);
-	dsi_dcs_write_seq(dsi, KD35T133_CMD_POWERCONTROL1, 0x18, 0x17);
-	dsi_dcs_write_seq(dsi, KD35T133_CMD_POWERCONTROL2, 0x41);
-	dsi_dcs_write_seq(dsi, KD35T133_CMD_VCOMCONTROL, 0x00, 0x1a, 0x80);
-	dsi_dcs_write_seq(dsi, MIPI_DCS_SET_ADDRESS_MODE, 0x48);
-	dsi_dcs_write_seq(dsi, MIPI_DCS_SET_PIXEL_FORMAT, 0x55);
-	dsi_dcs_write_seq(dsi, KD35T133_CMD_INTERFACEMODECTRL, 0x00);
-	dsi_dcs_write_seq(dsi, KD35T133_CMD_FRAMERATECTRL, 0xa0);
-	dsi_dcs_write_seq(dsi, KD35T133_CMD_DISPLAYINVERSIONCTRL, 0x02);
-	dsi_dcs_write_seq(dsi, KD35T133_CMD_DISPLAYFUNCTIONCTRL,
-			  0x20, 0x02);
-	dsi_dcs_write_seq(dsi, KD35T133_CMD_SETIMAGEFUNCTION, 0x00);
-	dsi_dcs_write_seq(dsi, KD35T133_CMD_ADJUSTCONTROL3,
-			  0xa9, 0x51, 0x2c, 0x82);
+	mipi_dsi_dcs_write_seq(dsi, KD35T133_CMD_POSITIVEGAMMA,
+			       0x00, 0x13, 0x18, 0x04, 0x0f, 0x06, 0x3a, 0x56,
+			       0x4d, 0x03, 0x0a, 0x06, 0x30, 0x3e, 0x0f);
+	mipi_dsi_dcs_write_seq(dsi, KD35T133_CMD_NEGATIVEGAMMA,
+			       0x00, 0x13, 0x18, 0x01, 0x11, 0x06, 0x38, 0x34,
+			       0x4d, 0x06, 0x0d, 0x0b, 0x31, 0x37, 0x0f);
+	mipi_dsi_dcs_write_seq(dsi, KD35T133_CMD_POWERCONTROL1, 0x18, 0x17);
+	mipi_dsi_dcs_write_seq(dsi, KD35T133_CMD_POWERCONTROL2, 0x41);
+	mipi_dsi_dcs_write_seq(dsi, KD35T133_CMD_VCOMCONTROL, 0x00, 0x1a, 0x80);
+	mipi_dsi_dcs_write_seq(dsi, MIPI_DCS_SET_ADDRESS_MODE, 0x48);
+	mipi_dsi_dcs_write_seq(dsi, MIPI_DCS_SET_PIXEL_FORMAT, 0x55);
+	mipi_dsi_dcs_write_seq(dsi, KD35T133_CMD_INTERFACEMODECTRL, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, KD35T133_CMD_FRAMERATECTRL, 0xa0);
+	mipi_dsi_dcs_write_seq(dsi, KD35T133_CMD_DISPLAYINVERSIONCTRL, 0x02);
+	mipi_dsi_dcs_write_seq(dsi, KD35T133_CMD_DISPLAYFUNCTIONCTRL,
+			       0x20, 0x02);
+	mipi_dsi_dcs_write_seq(dsi, KD35T133_CMD_SETIMAGEFUNCTION, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, KD35T133_CMD_ADJUSTCONTROL3,
+			       0xa9, 0x51, 0x2c, 0x82);
 	mipi_dsi_dcs_write(dsi, MIPI_DCS_ENTER_INVERT_MODE, NULL, 0);
 
 	dev_dbg(dev, "Panel init sequence done\n");
@@ -115,6 +107,8 @@ static int kd35t133_unprepare(struct drm
 	regulator_disable(ctx->iovcc);
 	regulator_disable(ctx->vdd);
 
+	gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+
 	ctx->prepared = false;
 
 	return 0;
diff -rupN linux.orig/drivers/gpu/drm/panel/panel-newvision-nv3051d.c linux/drivers/gpu/drm/panel/panel-newvision-nv3051d.c
--- linux.orig/drivers/gpu/drm/panel/panel-newvision-nv3051d.c	1970-01-01 00:00:00.000000000 +0000
+++ linux/drivers/gpu/drm/panel/panel-newvision-nv3051d.c	2023-10-28 04:02:49.341614140 +0000
@@ -0,0 +1,518 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * NV3051D MIPI-DSI panel driver for Anbernic RG353x
+ * Copyright (C) 2022 Chris Morgan
+ *
+ * based on
+ *
+ * Elida kd35t133 3.5" MIPI-DSI panel driver
+ * Copyright (C) Theobroma Systems 2020
+ */
+
+#include <linux/delay.h>
+#include <linux/gpio/consumer.h>
+#include <linux/media-bus-format.h>
+#include <linux/module.h>
+#include <linux/of_device.h>
+#include <linux/regulator/consumer.h>
+
+#include <video/display_timing.h>
+#include <video/mipi_display.h>
+
+#include <drm/drm_mipi_dsi.h>
+#include <drm/drm_modes.h>
+#include <drm/drm_panel.h>
+
+struct nv3051d_panel_info {
+	const struct drm_display_mode *display_modes;
+	unsigned int num_modes;
+	u16 width_mm, height_mm;
+	u32 bus_flags;
+	unsigned long mode_flags;
+};
+
+struct panel_nv3051d {
+	struct device *dev;
+	struct drm_panel panel;
+	struct gpio_desc *reset_gpio;
+	const struct nv3051d_panel_info *panel_info;
+	struct regulator *vdd;
+};
+
+static inline struct panel_nv3051d *panel_to_panelnv3051d(struct drm_panel *panel)
+{
+	return container_of(panel, struct panel_nv3051d, panel);
+}
+
+static int panel_nv3051d_init_sequence(struct panel_nv3051d *ctx)
+{
+	struct mipi_dsi_device *dsi = to_mipi_dsi_device(ctx->dev);
+
+	/*
+	 * Init sequence was supplied by device vendor with no
+	 * documentation.
+	 */
+
+	mipi_dsi_dcs_write_seq(dsi, 0xFF, 0x30);
+	mipi_dsi_dcs_write_seq(dsi, 0xFF, 0x52);
+	mipi_dsi_dcs_write_seq(dsi, 0xFF, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0xE3, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x03, 0x40);
+	mipi_dsi_dcs_write_seq(dsi, 0x04, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x05, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0x24, 0x12);
+	mipi_dsi_dcs_write_seq(dsi, 0x25, 0x1E);
+	mipi_dsi_dcs_write_seq(dsi, 0x26, 0x28);
+	mipi_dsi_dcs_write_seq(dsi, 0x27, 0x52);
+	mipi_dsi_dcs_write_seq(dsi, 0x28, 0x57);
+	mipi_dsi_dcs_write_seq(dsi, 0x29, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0x2A, 0xDF);
+	mipi_dsi_dcs_write_seq(dsi, 0x38, 0x9C);
+	mipi_dsi_dcs_write_seq(dsi, 0x39, 0xA7);
+	mipi_dsi_dcs_write_seq(dsi, 0x3A, 0x53);
+	mipi_dsi_dcs_write_seq(dsi, 0x44, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x49, 0x3C);
+	mipi_dsi_dcs_write_seq(dsi, 0x59, 0xFE);
+	mipi_dsi_dcs_write_seq(dsi, 0x5C, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x91, 0x77);
+	mipi_dsi_dcs_write_seq(dsi, 0x92, 0x77);
+	mipi_dsi_dcs_write_seq(dsi, 0xA0, 0x55);
+	mipi_dsi_dcs_write_seq(dsi, 0xA1, 0x50);
+	mipi_dsi_dcs_write_seq(dsi, 0xA4, 0x9C);
+	mipi_dsi_dcs_write_seq(dsi, 0xA7, 0x02);
+	mipi_dsi_dcs_write_seq(dsi, 0xA8, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0xA9, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0xAA, 0xFC);
+	mipi_dsi_dcs_write_seq(dsi, 0xAB, 0x28);
+	mipi_dsi_dcs_write_seq(dsi, 0xAC, 0x06);
+	mipi_dsi_dcs_write_seq(dsi, 0xAD, 0x06);
+	mipi_dsi_dcs_write_seq(dsi, 0xAE, 0x06);
+	mipi_dsi_dcs_write_seq(dsi, 0xAF, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0xB0, 0x08);
+	mipi_dsi_dcs_write_seq(dsi, 0xB1, 0x26);
+	mipi_dsi_dcs_write_seq(dsi, 0xB2, 0x28);
+	mipi_dsi_dcs_write_seq(dsi, 0xB3, 0x28);
+	mipi_dsi_dcs_write_seq(dsi, 0xB4, 0x33);
+	mipi_dsi_dcs_write_seq(dsi, 0xB5, 0x08);
+	mipi_dsi_dcs_write_seq(dsi, 0xB6, 0x26);
+	mipi_dsi_dcs_write_seq(dsi, 0xB7, 0x08);
+	mipi_dsi_dcs_write_seq(dsi, 0xB8, 0x26);
+	mipi_dsi_dcs_write_seq(dsi, 0xFF, 0x30);
+	mipi_dsi_dcs_write_seq(dsi, 0xFF, 0x52);
+	mipi_dsi_dcs_write_seq(dsi, 0xFF, 0x02);
+	mipi_dsi_dcs_write_seq(dsi, 0xB1, 0x0E);
+	mipi_dsi_dcs_write_seq(dsi, 0xD1, 0x0E);
+	mipi_dsi_dcs_write_seq(dsi, 0xB4, 0x29);
+	mipi_dsi_dcs_write_seq(dsi, 0xD4, 0x2B);
+	mipi_dsi_dcs_write_seq(dsi, 0xB2, 0x0C);
+	mipi_dsi_dcs_write_seq(dsi, 0xD2, 0x0A);
+	mipi_dsi_dcs_write_seq(dsi, 0xB3, 0x28);
+	mipi_dsi_dcs_write_seq(dsi, 0xD3, 0x28);
+	mipi_dsi_dcs_write_seq(dsi, 0xB6, 0x11);
+	mipi_dsi_dcs_write_seq(dsi, 0xD6, 0x0D);
+	mipi_dsi_dcs_write_seq(dsi, 0xB7, 0x32);
+	mipi_dsi_dcs_write_seq(dsi, 0xD7, 0x30);
+	mipi_dsi_dcs_write_seq(dsi, 0xC1, 0x04);
+	mipi_dsi_dcs_write_seq(dsi, 0xE1, 0x06);
+	mipi_dsi_dcs_write_seq(dsi, 0xB8, 0x0A);
+	mipi_dsi_dcs_write_seq(dsi, 0xD8, 0x0A);
+	mipi_dsi_dcs_write_seq(dsi, 0xB9, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0xD9, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0xBD, 0x13);
+	mipi_dsi_dcs_write_seq(dsi, 0xDD, 0x13);
+	mipi_dsi_dcs_write_seq(dsi, 0xBC, 0x11);
+	mipi_dsi_dcs_write_seq(dsi, 0xDC, 0x11);
+	mipi_dsi_dcs_write_seq(dsi, 0xBB, 0x0F);
+	mipi_dsi_dcs_write_seq(dsi, 0xDB, 0x0F);
+	mipi_dsi_dcs_write_seq(dsi, 0xBA, 0x0F);
+	mipi_dsi_dcs_write_seq(dsi, 0xDA, 0x0F);
+	mipi_dsi_dcs_write_seq(dsi, 0xBE, 0x18);
+	mipi_dsi_dcs_write_seq(dsi, 0xDE, 0x18);
+	mipi_dsi_dcs_write_seq(dsi, 0xBF, 0x0F);
+	mipi_dsi_dcs_write_seq(dsi, 0xDF, 0x0F);
+	mipi_dsi_dcs_write_seq(dsi, 0xC0, 0x17);
+	mipi_dsi_dcs_write_seq(dsi, 0xE0, 0x17);
+	mipi_dsi_dcs_write_seq(dsi, 0xB5, 0x3B);
+	mipi_dsi_dcs_write_seq(dsi, 0xD5, 0x3C);
+	mipi_dsi_dcs_write_seq(dsi, 0xB0, 0x0B);
+	mipi_dsi_dcs_write_seq(dsi, 0xD0, 0x0C);
+	mipi_dsi_dcs_write_seq(dsi, 0xFF, 0x30);
+	mipi_dsi_dcs_write_seq(dsi, 0xFF, 0x52);
+	mipi_dsi_dcs_write_seq(dsi, 0xFF, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0x00, 0x2A);
+	mipi_dsi_dcs_write_seq(dsi, 0x01, 0x2A);
+	mipi_dsi_dcs_write_seq(dsi, 0x02, 0x2A);
+	mipi_dsi_dcs_write_seq(dsi, 0x03, 0x2A);
+	mipi_dsi_dcs_write_seq(dsi, 0x04, 0x61);
+	mipi_dsi_dcs_write_seq(dsi, 0x05, 0x80);
+	mipi_dsi_dcs_write_seq(dsi, 0x06, 0xC7);
+	mipi_dsi_dcs_write_seq(dsi, 0x07, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0x08, 0x82);
+	mipi_dsi_dcs_write_seq(dsi, 0x09, 0x83);
+	mipi_dsi_dcs_write_seq(dsi, 0x30, 0x2A);
+	mipi_dsi_dcs_write_seq(dsi, 0x31, 0x2A);
+	mipi_dsi_dcs_write_seq(dsi, 0x32, 0x2A);
+	mipi_dsi_dcs_write_seq(dsi, 0x33, 0x2A);
+	mipi_dsi_dcs_write_seq(dsi, 0x34, 0x61);
+	mipi_dsi_dcs_write_seq(dsi, 0x35, 0xC5);
+	mipi_dsi_dcs_write_seq(dsi, 0x36, 0x80);
+	mipi_dsi_dcs_write_seq(dsi, 0x37, 0x23);
+	mipi_dsi_dcs_write_seq(dsi, 0x40, 0x82);
+	mipi_dsi_dcs_write_seq(dsi, 0x41, 0x83);
+	mipi_dsi_dcs_write_seq(dsi, 0x42, 0x80);
+	mipi_dsi_dcs_write_seq(dsi, 0x43, 0x81);
+	mipi_dsi_dcs_write_seq(dsi, 0x44, 0x11);
+	mipi_dsi_dcs_write_seq(dsi, 0x45, 0xF2);
+	mipi_dsi_dcs_write_seq(dsi, 0x46, 0xF1);
+	mipi_dsi_dcs_write_seq(dsi, 0x47, 0x11);
+	mipi_dsi_dcs_write_seq(dsi, 0x48, 0xF4);
+	mipi_dsi_dcs_write_seq(dsi, 0x49, 0xF3);
+	mipi_dsi_dcs_write_seq(dsi, 0x50, 0x02);
+	mipi_dsi_dcs_write_seq(dsi, 0x51, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0x52, 0x04);
+	mipi_dsi_dcs_write_seq(dsi, 0x53, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0x54, 0x11);
+	mipi_dsi_dcs_write_seq(dsi, 0x55, 0xF6);
+	mipi_dsi_dcs_write_seq(dsi, 0x56, 0xF5);
+	mipi_dsi_dcs_write_seq(dsi, 0x57, 0x11);
+	mipi_dsi_dcs_write_seq(dsi, 0x58, 0xF8);
+	mipi_dsi_dcs_write_seq(dsi, 0x59, 0xF7);
+	mipi_dsi_dcs_write_seq(dsi, 0x7E, 0x02);
+	mipi_dsi_dcs_write_seq(dsi, 0x7F, 0x80);
+	mipi_dsi_dcs_write_seq(dsi, 0xE0, 0x5A);
+	mipi_dsi_dcs_write_seq(dsi, 0xB1, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0xB4, 0x0E);
+	mipi_dsi_dcs_write_seq(dsi, 0xB5, 0x0F);
+	mipi_dsi_dcs_write_seq(dsi, 0xB6, 0x04);
+	mipi_dsi_dcs_write_seq(dsi, 0xB7, 0x07);
+	mipi_dsi_dcs_write_seq(dsi, 0xB8, 0x06);
+	mipi_dsi_dcs_write_seq(dsi, 0xB9, 0x05);
+	mipi_dsi_dcs_write_seq(dsi, 0xBA, 0x0F);
+	mipi_dsi_dcs_write_seq(dsi, 0xC7, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0xCA, 0x0E);
+	mipi_dsi_dcs_write_seq(dsi, 0xCB, 0x0F);
+	mipi_dsi_dcs_write_seq(dsi, 0xCC, 0x04);
+	mipi_dsi_dcs_write_seq(dsi, 0xCD, 0x07);
+	mipi_dsi_dcs_write_seq(dsi, 0xCE, 0x06);
+	mipi_dsi_dcs_write_seq(dsi, 0xCF, 0x05);
+	mipi_dsi_dcs_write_seq(dsi, 0xD0, 0x0F);
+	mipi_dsi_dcs_write_seq(dsi, 0x81, 0x0F);
+	mipi_dsi_dcs_write_seq(dsi, 0x84, 0x0E);
+	mipi_dsi_dcs_write_seq(dsi, 0x85, 0x0F);
+	mipi_dsi_dcs_write_seq(dsi, 0x86, 0x07);
+	mipi_dsi_dcs_write_seq(dsi, 0x87, 0x04);
+	mipi_dsi_dcs_write_seq(dsi, 0x88, 0x05);
+	mipi_dsi_dcs_write_seq(dsi, 0x89, 0x06);
+	mipi_dsi_dcs_write_seq(dsi, 0x8A, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x97, 0x0F);
+	mipi_dsi_dcs_write_seq(dsi, 0x9A, 0x0E);
+	mipi_dsi_dcs_write_seq(dsi, 0x9B, 0x0F);
+	mipi_dsi_dcs_write_seq(dsi, 0x9C, 0x07);
+	mipi_dsi_dcs_write_seq(dsi, 0x9D, 0x04);
+	mipi_dsi_dcs_write_seq(dsi, 0x9E, 0x05);
+	mipi_dsi_dcs_write_seq(dsi, 0x9F, 0x06);
+	mipi_dsi_dcs_write_seq(dsi, 0xA0, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0xFF, 0x30);
+	mipi_dsi_dcs_write_seq(dsi, 0xFF, 0x52);
+	mipi_dsi_dcs_write_seq(dsi, 0xFF, 0x02);
+	mipi_dsi_dcs_write_seq(dsi, 0x01, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0x02, 0xDA);
+	mipi_dsi_dcs_write_seq(dsi, 0x03, 0xBA);
+	mipi_dsi_dcs_write_seq(dsi, 0x04, 0xA8);
+	mipi_dsi_dcs_write_seq(dsi, 0x05, 0x9A);
+	mipi_dsi_dcs_write_seq(dsi, 0x06, 0x70);
+	mipi_dsi_dcs_write_seq(dsi, 0x07, 0xFF);
+	mipi_dsi_dcs_write_seq(dsi, 0x08, 0x91);
+	mipi_dsi_dcs_write_seq(dsi, 0x09, 0x90);
+	mipi_dsi_dcs_write_seq(dsi, 0x0A, 0xFF);
+	mipi_dsi_dcs_write_seq(dsi, 0x0B, 0x8F);
+	mipi_dsi_dcs_write_seq(dsi, 0x0C, 0x60);
+	mipi_dsi_dcs_write_seq(dsi, 0x0D, 0x58);
+	mipi_dsi_dcs_write_seq(dsi, 0x0E, 0x48);
+	mipi_dsi_dcs_write_seq(dsi, 0x0F, 0x38);
+	mipi_dsi_dcs_write_seq(dsi, 0x10, 0x2B);
+	mipi_dsi_dcs_write_seq(dsi, 0xFF, 0x30);
+	mipi_dsi_dcs_write_seq(dsi, 0xFF, 0x52);
+	mipi_dsi_dcs_write_seq(dsi, 0xFF, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x36, 0x02);
+	mipi_dsi_dcs_write_seq(dsi, 0x3A, 0x70);
+
+	dev_dbg(ctx->dev, "Panel init sequence done\n");
+
+	return 0;
+}
+
+static int panel_nv3051d_unprepare(struct drm_panel *panel)
+{
+	struct panel_nv3051d *ctx = panel_to_panelnv3051d(panel);
+	struct mipi_dsi_device *dsi = to_mipi_dsi_device(ctx->dev);
+	int ret;
+
+	ret = mipi_dsi_dcs_set_display_off(dsi);
+	if (ret < 0)
+		dev_err(ctx->dev, "failed to set display off: %d\n", ret);
+
+	msleep(20);
+
+	ret = mipi_dsi_dcs_enter_sleep_mode(dsi);
+	if (ret < 0) {
+		dev_err(ctx->dev, "failed to enter sleep mode: %d\n", ret);
+		return ret;
+	}
+
+	usleep_range(10000, 15000);
+
+	regulator_disable(ctx->vdd);
+
+	return 0;
+}
+
+static int panel_nv3051d_prepare(struct drm_panel *panel)
+{
+	struct panel_nv3051d *ctx = panel_to_panelnv3051d(panel);
+	struct mipi_dsi_device *dsi = to_mipi_dsi_device(ctx->dev);
+	int ret;
+
+	dev_dbg(ctx->dev, "Resetting the panel\n");
+	ret = regulator_enable(ctx->vdd);
+	if (ret < 0) {
+		dev_err(ctx->dev, "Failed to enable vdd supply: %d\n", ret);
+		return ret;
+	}
+
+	usleep_range(2000, 3000);
+	gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+	msleep(150);
+	gpiod_set_value_cansleep(ctx->reset_gpio, 0);
+	msleep(20);
+
+	ret = panel_nv3051d_init_sequence(ctx);
+	if (ret < 0) {
+		dev_err(ctx->dev, "Panel init sequence failed: %d\n", ret);
+		goto disable_vdd;
+	}
+
+	ret = mipi_dsi_dcs_exit_sleep_mode(dsi);
+	if (ret < 0) {
+		dev_err(ctx->dev, "Failed to exit sleep mode: %d\n", ret);
+		goto disable_vdd;
+	}
+
+	msleep(200);
+
+	ret = mipi_dsi_dcs_set_display_on(dsi);
+	if (ret < 0) {
+		dev_err(ctx->dev, "Failed to set display on: %d\n", ret);
+		goto disable_vdd;
+	}
+
+	usleep_range(10000, 15000);
+
+	return 0;
+
+disable_vdd:
+	regulator_disable(ctx->vdd);
+	return ret;
+}
+
+static int panel_nv3051d_get_modes(struct drm_panel *panel,
+				   struct drm_connector *connector)
+{
+	struct panel_nv3051d *ctx = panel_to_panelnv3051d(panel);
+	const struct nv3051d_panel_info *panel_info = ctx->panel_info;
+	struct drm_display_mode *mode;
+	unsigned int i;
+
+	for (i = 0; i < panel_info->num_modes; i++) {
+		mode = drm_mode_duplicate(connector->dev,
+					  &panel_info->display_modes[i]);
+		if (!mode)
+			return -ENOMEM;
+
+		drm_mode_set_name(mode);
+
+		mode->type = DRM_MODE_TYPE_DRIVER;
+		if (panel_info->num_modes == 1)
+			mode->type |= DRM_MODE_TYPE_PREFERRED;
+
+		drm_mode_probed_add(connector, mode);
+	}
+
+	connector->display_info.bpc = 8;
+	connector->display_info.width_mm = panel_info->width_mm;
+	connector->display_info.height_mm = panel_info->height_mm;
+	connector->display_info.bus_flags = panel_info->bus_flags;
+
+	return panel_info->num_modes;
+}
+
+static const struct drm_panel_funcs panel_nv3051d_funcs = {
+	.unprepare	= panel_nv3051d_unprepare,
+	.prepare	= panel_nv3051d_prepare,
+	.get_modes	= panel_nv3051d_get_modes,
+};
+
+static int panel_nv3051d_probe(struct mipi_dsi_device *dsi)
+{
+	struct device *dev = &dsi->dev;
+	struct panel_nv3051d *ctx;
+	int ret;
+
+	ctx = devm_kzalloc(dev, sizeof(*ctx), GFP_KERNEL);
+	if (!ctx)
+		return -ENOMEM;
+
+	ctx->dev = dev;
+
+	ctx->panel_info = of_device_get_match_data(dev);
+	if (!ctx->panel_info)
+		return -EINVAL;
+
+	ctx->reset_gpio = devm_gpiod_get_optional(dev, "reset", GPIOD_OUT_HIGH);
+	if (IS_ERR(ctx->reset_gpio)) {
+		dev_err(dev, "cannot get reset gpio\n");
+		return PTR_ERR(ctx->reset_gpio);
+	}
+
+	ctx->vdd = devm_regulator_get(dev, "vdd");
+	if (IS_ERR(ctx->vdd)) {
+		ret = PTR_ERR(ctx->vdd);
+		if (ret != -EPROBE_DEFER)
+			dev_err(dev, "Failed to request vdd regulator: %d\n", ret);
+		return ret;
+	}
+
+	mipi_dsi_set_drvdata(dsi, ctx);
+
+	dsi->lanes = 4;
+	dsi->format = MIPI_DSI_FMT_RGB888;
+	dsi->mode_flags = ctx->panel_info->mode_flags;
+
+	drm_panel_init(&ctx->panel, &dsi->dev, &panel_nv3051d_funcs,
+		       DRM_MODE_CONNECTOR_DSI);
+
+	ret = drm_panel_of_backlight(&ctx->panel);
+	if (ret)
+		return ret;
+
+	drm_panel_add(&ctx->panel);
+
+	ret = mipi_dsi_attach(dsi);
+	if (ret < 0) {
+		dev_err(dev, "mipi_dsi_attach failed: %d\n", ret);
+		drm_panel_remove(&ctx->panel);
+		return ret;
+	}
+
+	return 0;
+}
+
+static void panel_nv3051d_shutdown(struct mipi_dsi_device *dsi)
+{
+	struct panel_nv3051d *ctx = mipi_dsi_get_drvdata(dsi);
+	int ret;
+
+	ret = drm_panel_unprepare(&ctx->panel);
+	if (ret < 0)
+		dev_err(&dsi->dev, "Failed to unprepare panel: %d\n", ret);
+
+	ret = drm_panel_disable(&ctx->panel);
+	if (ret < 0)
+		dev_err(&dsi->dev, "Failed to disable panel: %d\n", ret);
+}
+
+static void panel_nv3051d_remove(struct mipi_dsi_device *dsi)
+{
+	struct panel_nv3051d *ctx = mipi_dsi_get_drvdata(dsi);
+	int ret;
+
+	panel_nv3051d_shutdown(dsi);
+
+	ret = mipi_dsi_detach(dsi);
+	if (ret < 0)
+		dev_err(&dsi->dev, "Failed to detach from DSI host: %d\n", ret);
+
+	drm_panel_remove(&ctx->panel);
+}
+
+static const struct drm_display_mode nv3051d_rgxx3_modes[] = {
+	{ /* 120hz */
+		.hdisplay	= 640,
+		.hsync_start	= 640 + 40,
+		.hsync_end	= 640 + 40 + 2,
+		.htotal		= 640 + 40 + 2 + 80,
+		.vdisplay	= 480,
+		.vsync_start	= 480 + 18,
+		.vsync_end	= 480 + 18 + 2,
+		.vtotal		= 480 + 18 + 2 + 28,
+		.clock		= 48300,
+		.flags		= DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC,
+	},
+	{ /* 100hz */
+		.hdisplay       = 640,
+		.hsync_start    = 640 + 40,
+		.hsync_end      = 640 + 40 + 2,
+		.htotal         = 640 + 40 + 2 + 80,
+		.vdisplay       = 480,
+		.vsync_start    = 480 + 18,
+		.vsync_end      = 480 + 18 + 2,
+		.vtotal         = 480 + 18 + 2 + 28,
+		.clock          = 40250,
+		.flags		= DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC,
+	},
+	{ /* 60hz */
+		.hdisplay	= 640,
+		.hsync_start	= 640 + 40,
+		.hsync_end	= 640 + 40 + 2,
+		.htotal		= 640 + 40 + 2 + 80,
+		.vdisplay	= 480,
+		.vsync_start	= 480 + 18,
+		.vsync_end	= 480 + 18 + 2,
+		.vtotal		= 480 + 18 + 2 + 28,
+		.clock		= 24150,
+		.flags		= DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC,
+	},
+};
+
+static const struct nv3051d_panel_info nv3051d_rgxx3_info = {
+	.display_modes = nv3051d_rgxx3_modes,
+	.num_modes = ARRAY_SIZE(nv3051d_rgxx3_modes),
+	.width_mm = 70,
+	.height_mm = 57,
+	.bus_flags = DRM_BUS_FLAG_DE_LOW | DRM_BUS_FLAG_PIXDATA_DRIVE_NEGEDGE,
+	.mode_flags = MIPI_DSI_MODE_VIDEO | MIPI_DSI_MODE_VIDEO_BURST |
+		      MIPI_DSI_MODE_LPM | MIPI_DSI_MODE_NO_EOT_PACKET,
+};
+
+static const struct nv3051d_panel_info nv3051d_rg351v_info = {
+	.display_modes = nv3051d_rgxx3_modes,
+	.num_modes = ARRAY_SIZE(nv3051d_rgxx3_modes),
+	.width_mm = 70,
+	.height_mm = 57,
+	.bus_flags = DRM_BUS_FLAG_DE_LOW | DRM_BUS_FLAG_PIXDATA_DRIVE_NEGEDGE,
+	.mode_flags = MIPI_DSI_MODE_VIDEO | MIPI_DSI_MODE_VIDEO_BURST |
+		      MIPI_DSI_MODE_LPM | MIPI_DSI_MODE_NO_EOT_PACKET |
+		      MIPI_DSI_CLOCK_NON_CONTINUOUS,
+};
+
+static const struct of_device_id newvision_nv3051d_of_match[] = {
+	{ .compatible = "newvision,nv3051d", .data = &nv3051d_rgxx3_info },
+	{ .compatible = "anbernic,rg351v-panel", .data = &nv3051d_rg351v_info },
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, newvision_nv3051d_of_match);
+
+static struct mipi_dsi_driver newvision_nv3051d_driver = {
+	.driver = {
+		.name = "panel-newvision-nv3051d",
+		.of_match_table = newvision_nv3051d_of_match,
+	},
+	.probe	= panel_nv3051d_probe,
+	.remove = panel_nv3051d_remove,
+	.shutdown = panel_nv3051d_shutdown,
+};
+module_mipi_dsi_driver(newvision_nv3051d_driver);
+
+MODULE_AUTHOR("Chris Morgan <macromorgan@hotmail.com>");
+MODULE_DESCRIPTION("DRM driver for Newvision NV3051D based MIPI DSI panels");
+MODULE_LICENSE("GPL");
diff -rupN linux.orig/drivers/gpu/drm/panel/panel-sitronix-st7701.c linux/drivers/gpu/drm/panel/panel-sitronix-st7701.c
--- linux.orig/drivers/gpu/drm/panel/panel-sitronix-st7701.c	2023-10-27 21:46:02.272576875 +0000
+++ linux/drivers/gpu/drm/panel/panel-sitronix-st7701.c	2023-10-28 04:02:49.341614140 +0000
@@ -19,6 +19,9 @@
 
 /* Command2 BKx selection command */
 #define DSI_CMD2BKX_SEL			0xFF
+#define DSI_CMD1			0
+#define DSI_CMD2			BIT(4)
+#define DSI_CMD2BK_MASK			GENMASK(3, 0)
 
 /* Command2, BK0 commands */
 #define DSI_CMD2_BK0_PVGAMCTRL		0xB0 /* Positive Voltage Gamma Control */
@@ -39,21 +42,6 @@
 #define DSI_CMD2_BK1_SPD2		0xC2 /* Source EQ2 Setting */
 #define DSI_CMD2_BK1_MIPISET1		0xD0 /* MIPI Setting 1 */
 
-/*
- * Command2 with BK function selection.
- *
- * BIT[4].....CN2
- * BIT[1:0]...BKXSEL
- * 1:00 = CMD2BK0, Command2 BK0
- * 1:01 = CMD2BK1, Command2 BK1
- * 1:11 = CMD2BK3, Command2 BK3
- * 0:00 = Command2 disable
- */
-#define DSI_CMD2BK0_SEL			0x10
-#define DSI_CMD2BK1_SEL			0x11
-#define DSI_CMD2BK3_SEL			0x13
-#define DSI_CMD2BKX_SEL_NONE		0x00
-
 /* Command2, BK0 bytes */
 #define DSI_CMD2_BK0_GAMCTRL_AJ_MASK	GENMASK(7, 6)
 #define DSI_CMD2_BK0_GAMCTRL_VC0_MASK	GENMASK(3, 0)
@@ -147,6 +135,7 @@ struct st7701 {
 	struct regulator_bulk_data supplies[2];
 	struct gpio_desc *reset;
 	unsigned int sleep_delay;
+	enum drm_panel_orientation orientation;
 };
 
 static inline struct st7701 *panel_to_st7701(struct drm_panel *panel)
@@ -191,6 +180,18 @@ static u8 st7701_vgls_map(struct st7701
 	return 0;
 }
 
+static void st7701_switch_cmd_bkx(struct st7701 *st7701, bool cmd2, u8 bkx)
+{
+	u8 val;
+
+	if (cmd2)
+		val = DSI_CMD2 | FIELD_PREP(DSI_CMD2BK_MASK, bkx);
+	else
+		val = DSI_CMD1;
+
+	ST7701_DSI(st7701, DSI_CMD2BKX_SEL, 0x77, 0x01, 0x00, 0x00, val);
+}
+
 static void st7701_init_sequence(struct st7701 *st7701)
 {
 	const struct st7701_panel_desc *desc = st7701->desc;
@@ -208,8 +209,8 @@ static void st7701_init_sequence(struct
 	msleep(st7701->sleep_delay);
 
 	/* Command2, BK0 */
-	ST7701_DSI(st7701, DSI_CMD2BKX_SEL,
-		   0x77, 0x01, 0x00, 0x00, DSI_CMD2BK0_SEL);
+	st7701_switch_cmd_bkx(st7701, true, 0);
+
 	mipi_dsi_dcs_write(st7701->dsi, DSI_CMD2_BK0_PVGAMCTRL,
 			   desc->pv_gamma, ARRAY_SIZE(desc->pv_gamma));
 	mipi_dsi_dcs_write(st7701->dsi, DSI_CMD2_BK0_NVGAMCTRL,
@@ -247,8 +248,7 @@ static void st7701_init_sequence(struct
 			      (clamp((u32)mode->htotal, 512U, 1008U) - 512) / 16));
 
 	/* Command2, BK1 */
-	ST7701_DSI(st7701, DSI_CMD2BKX_SEL,
-			0x77, 0x01, 0x00, 0x00, DSI_CMD2BK1_SEL);
+	st7701_switch_cmd_bkx(st7701, true, 1);
 
 	/* Vop = 3.5375V + (VRHA[7:0] * 0.0125V) */
 	ST7701_DSI(st7701, DSI_CMD2_BK1_VRHS,
@@ -373,37 +373,56 @@ static void dmt028vghmcmi_1a_gip_sequenc
 		   0x08, 0x08, 0x08, 0x40,
 			   0x3F, 0x64);
 
-	ST7701_DSI(st7701, DSI_CMD2BKX_SEL,
-		   0x77, 0x01, 0x00, 0x00, DSI_CMD2BKX_SEL_NONE);
+	st7701_switch_cmd_bkx(st7701, false, 0);
 
-	ST7701_DSI(st7701, DSI_CMD2BKX_SEL,
-		   0x77, 0x01, 0x00, 0x00, DSI_CMD2BK3_SEL);
+	st7701_switch_cmd_bkx(st7701, true, 3);
 	ST7701_DSI(st7701, 0xE6, 0x7C);
 	ST7701_DSI(st7701, 0xE8, 0x00, 0x0E);
 
-	ST7701_DSI(st7701, DSI_CMD2BKX_SEL,
-		   0x77, 0x01, 0x00, 0x00, DSI_CMD2BKX_SEL_NONE);
+	st7701_switch_cmd_bkx(st7701, false, 0);
 	ST7701_DSI(st7701, 0x11);
 	msleep(120);
 
-	ST7701_DSI(st7701, DSI_CMD2BKX_SEL,
-		   0x77, 0x01, 0x00, 0x00, DSI_CMD2BK3_SEL);
+	st7701_switch_cmd_bkx(st7701, true, 3);
 	ST7701_DSI(st7701, 0xE8, 0x00, 0x0C);
 	msleep(10);
 	ST7701_DSI(st7701, 0xE8, 0x00, 0x00);
 
-	ST7701_DSI(st7701, DSI_CMD2BKX_SEL,
-		   0x77, 0x01, 0x00, 0x00, DSI_CMD2BKX_SEL_NONE);
+	st7701_switch_cmd_bkx(st7701, false, 0);
 	ST7701_DSI(st7701, 0x11);
 	msleep(120);
 	ST7701_DSI(st7701, 0xE8, 0x00, 0x00);
 
-	ST7701_DSI(st7701, DSI_CMD2BKX_SEL,
-		   0x77, 0x01, 0x00, 0x00, DSI_CMD2BKX_SEL_NONE);
+	st7701_switch_cmd_bkx(st7701, false, 0);
 
 	ST7701_DSI(st7701, 0x3A, 0x70);
 }
 
+static void kd50t048a_gip_sequence(struct st7701 *st7701)
+{
+	/**
+	 * ST7701_SPEC_V1.2 is unable to provide enough information above this
+	 * specific command sequence, so grab the same from vendor BSP driver.
+	 */
+	ST7701_DSI(st7701, 0xE0, 0x00, 0x00, 0x02);
+	ST7701_DSI(st7701, 0xE1, 0x08, 0x00, 0x0A, 0x00, 0x07, 0x00, 0x09,
+		   0x00, 0x00, 0x33, 0x33);
+	ST7701_DSI(st7701, 0xE2, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+		   0x00, 0x00, 0x00, 0x00, 0x00, 0x00);
+	ST7701_DSI(st7701, 0xE3, 0x00, 0x00, 0x33, 0x33);
+	ST7701_DSI(st7701, 0xE4, 0x44, 0x44);
+	ST7701_DSI(st7701, 0xE5, 0x0E, 0x60, 0xA0, 0xA0, 0x10, 0x60, 0xA0,
+		   0xA0, 0x0A, 0x60, 0xA0, 0xA0, 0x0C, 0x60, 0xA0, 0xA0);
+	ST7701_DSI(st7701, 0xE6, 0x00, 0x00, 0x33, 0x33);
+	ST7701_DSI(st7701, 0xE7, 0x44, 0x44);
+	ST7701_DSI(st7701, 0xE8, 0x0D, 0x60, 0xA0, 0xA0, 0x0F, 0x60, 0xA0,
+		   0xA0, 0x09, 0x60, 0xA0, 0xA0, 0x0B, 0x60, 0xA0, 0xA0);
+	ST7701_DSI(st7701, 0xEB, 0x02, 0x01, 0xE4, 0xE4, 0x44, 0x00, 0x40);
+	ST7701_DSI(st7701, 0xEC, 0x02, 0x01);
+	ST7701_DSI(st7701, 0xED, 0xAB, 0x89, 0x76, 0x54, 0x01, 0xFF, 0xFF,
+		   0xFF, 0xFF, 0xFF, 0xFF, 0x10, 0x45, 0x67, 0x98, 0xBA);
+}
+
 static int st7701_prepare(struct drm_panel *panel)
 {
 	struct st7701 *st7701 = panel_to_st7701(panel);
@@ -426,8 +445,7 @@ static int st7701_prepare(struct drm_pan
 		st7701->desc->gip_sequence(st7701);
 
 	/* Disable Command2 */
-	ST7701_DSI(st7701, DSI_CMD2BKX_SEL,
-		   0x77, 0x01, 0x00, 0x00, DSI_CMD2BKX_SEL_NONE);
+	st7701_switch_cmd_bkx(st7701, false, 0);
 
 	return 0;
 }
@@ -497,15 +515,29 @@ static int st7701_get_modes(struct drm_p
 	connector->display_info.width_mm = desc_mode->width_mm;
 	connector->display_info.height_mm = desc_mode->height_mm;
 
+	/*
+	 * TODO: Remove once all drm drivers call
+	 * drm_connector_set_orientation_from_panel()
+	 */
+	drm_connector_set_panel_orientation(connector, st7701->orientation);
+
 	return 1;
 }
 
+static enum drm_panel_orientation st7701_get_orientation(struct drm_panel *panel)
+{
+	struct st7701 *st7701 = panel_to_st7701(panel);
+
+	return st7701->orientation;
+}
+
 static const struct drm_panel_funcs st7701_funcs = {
 	.disable	= st7701_disable,
 	.unprepare	= st7701_unprepare,
 	.prepare	= st7701_prepare,
 	.enable		= st7701_enable,
 	.get_modes	= st7701_get_modes,
+	.get_orientation = st7701_get_orientation,
 };
 
 static const struct drm_display_mode ts8550b_mode = {
@@ -708,6 +740,105 @@ static const struct st7701_panel_desc dm
 	.gip_sequence = dmt028vghmcmi_1a_gip_sequence,
 };
 
+static const struct drm_display_mode kd50t048a_mode = {
+	.clock          = 27500,
+
+	.hdisplay       = 480,
+	.hsync_start    = 480 + 2,
+	.hsync_end      = 480 + 2 + 10,
+	.htotal         = 480 + 2 + 10 + 2,
+
+	.vdisplay       = 854,
+	.vsync_start    = 854 + 2,
+	.vsync_end      = 854 + 2 + 2,
+	.vtotal         = 854 + 2 + 2 + 17,
+
+	.width_mm       = 69,
+	.height_mm      = 139,
+
+	.type = DRM_MODE_TYPE_DRIVER | DRM_MODE_TYPE_PREFERRED,
+};
+
+static const struct st7701_panel_desc kd50t048a_desc = {
+	.mode = &kd50t048a_mode,
+	.lanes = 2,
+	.format = MIPI_DSI_FMT_RGB888,
+	.panel_sleep_delay = 0,
+
+	.pv_gamma = {
+		CFIELD_PREP(DSI_CMD2_BK0_GAMCTRL_AJ_MASK, 0) |
+		CFIELD_PREP(DSI_CMD2_BK0_GAMCTRL_VC0_MASK, 0),
+		CFIELD_PREP(DSI_CMD2_BK0_GAMCTRL_AJ_MASK, 0) |
+		CFIELD_PREP(DSI_CMD2_BK0_GAMCTRL_VC4_MASK, 0xd),
+		CFIELD_PREP(DSI_CMD2_BK0_GAMCTRL_AJ_MASK, 0) |
+		CFIELD_PREP(DSI_CMD2_BK0_GAMCTRL_VC8_MASK, 0x14),
+		CFIELD_PREP(DSI_CMD2_BK0_GAMCTRL_VC16_MASK, 0xd),
+
+		CFIELD_PREP(DSI_CMD2_BK0_GAMCTRL_AJ_MASK, 0) |
+		CFIELD_PREP(DSI_CMD2_BK0_GAMCTRL_VC24_MASK, 0x10),
+		CFIELD_PREP(DSI_CMD2_BK0_GAMCTRL_VC52_MASK, 0x5),
+		CFIELD_PREP(DSI_CMD2_BK0_GAMCTRL_VC80_MASK, 0x2),
+		CFIELD_PREP(DSI_CMD2_BK0_GAMCTRL_VC108_MASK, 0x8),
+
+		CFIELD_PREP(DSI_CMD2_BK0_GAMCTRL_VC147_MASK, 0x8),
+		CFIELD_PREP(DSI_CMD2_BK0_GAMCTRL_VC175_MASK, 0x1e),
+		CFIELD_PREP(DSI_CMD2_BK0_GAMCTRL_VC203_MASK, 0x5),
+		CFIELD_PREP(DSI_CMD2_BK0_GAMCTRL_AJ_MASK, 0) |
+		CFIELD_PREP(DSI_CMD2_BK0_GAMCTRL_VC231_MASK, 0x13),
+
+		CFIELD_PREP(DSI_CMD2_BK0_GAMCTRL_VC239_MASK, 0x11),
+		CFIELD_PREP(DSI_CMD2_BK0_GAMCTRL_AJ_MASK, 2) |
+		CFIELD_PREP(DSI_CMD2_BK0_GAMCTRL_VC247_MASK, 0x23),
+		CFIELD_PREP(DSI_CMD2_BK0_GAMCTRL_AJ_MASK, 0) |
+		CFIELD_PREP(DSI_CMD2_BK0_GAMCTRL_VC251_MASK, 0x29),
+		CFIELD_PREP(DSI_CMD2_BK0_GAMCTRL_AJ_MASK, 0) |
+		CFIELD_PREP(DSI_CMD2_BK0_GAMCTRL_VC255_MASK, 0x18)
+	},
+	.nv_gamma = {
+		CFIELD_PREP(DSI_CMD2_BK0_GAMCTRL_AJ_MASK, 0) |
+		CFIELD_PREP(DSI_CMD2_BK0_GAMCTRL_VC0_MASK, 0),
+		CFIELD_PREP(DSI_CMD2_BK0_GAMCTRL_AJ_MASK, 0) |
+		CFIELD_PREP(DSI_CMD2_BK0_GAMCTRL_VC4_MASK, 0xc),
+		CFIELD_PREP(DSI_CMD2_BK0_GAMCTRL_AJ_MASK, 0) |
+		CFIELD_PREP(DSI_CMD2_BK0_GAMCTRL_VC8_MASK, 0x14),
+		CFIELD_PREP(DSI_CMD2_BK0_GAMCTRL_VC16_MASK, 0xc),
+
+		CFIELD_PREP(DSI_CMD2_BK0_GAMCTRL_AJ_MASK, 0) |
+		CFIELD_PREP(DSI_CMD2_BK0_GAMCTRL_VC24_MASK, 0x10),
+		CFIELD_PREP(DSI_CMD2_BK0_GAMCTRL_VC52_MASK, 0x5),
+		CFIELD_PREP(DSI_CMD2_BK0_GAMCTRL_VC80_MASK, 0x3),
+		CFIELD_PREP(DSI_CMD2_BK0_GAMCTRL_VC108_MASK, 0x8),
+
+		CFIELD_PREP(DSI_CMD2_BK0_GAMCTRL_VC147_MASK, 0x7),
+		CFIELD_PREP(DSI_CMD2_BK0_GAMCTRL_VC175_MASK, 0x20),
+		CFIELD_PREP(DSI_CMD2_BK0_GAMCTRL_VC203_MASK, 0x5),
+		CFIELD_PREP(DSI_CMD2_BK0_GAMCTRL_AJ_MASK, 0) |
+		CFIELD_PREP(DSI_CMD2_BK0_GAMCTRL_VC231_MASK, 0x13),
+
+		CFIELD_PREP(DSI_CMD2_BK0_GAMCTRL_VC239_MASK, 0x11),
+		CFIELD_PREP(DSI_CMD2_BK0_GAMCTRL_AJ_MASK, 2) |
+		CFIELD_PREP(DSI_CMD2_BK0_GAMCTRL_VC247_MASK, 0x24),
+		CFIELD_PREP(DSI_CMD2_BK0_GAMCTRL_AJ_MASK, 0) |
+		CFIELD_PREP(DSI_CMD2_BK0_GAMCTRL_VC251_MASK, 0x29),
+		CFIELD_PREP(DSI_CMD2_BK0_GAMCTRL_AJ_MASK, 0) |
+		CFIELD_PREP(DSI_CMD2_BK0_GAMCTRL_VC255_MASK, 0x18)
+	},
+	.nlinv = 1,
+	.vop_uv = 4887500,
+	.vcom_uv = 937500,
+	.vgh_mv = 15000,
+	.vgl_mv = -9510,
+	.avdd_mv = 6600,
+	.avcl_mv = -4400,
+	.gamma_op_bias = OP_BIAS_MIDDLE,
+	.input_op_bias = OP_BIAS_MIN,
+	.output_op_bias = OP_BIAS_MIN,
+	.t2d_ns = 1600,
+	.t3d_ns = 10400,
+	.eot_en = true,
+	.gip_sequence = kd50t048a_gip_sequence,
+};
+
 static int st7701_dsi_probe(struct mipi_dsi_device *dsi)
 {
 	const struct st7701_panel_desc *desc;
@@ -738,6 +869,10 @@ static int st7701_dsi_probe(struct mipi_
 		return PTR_ERR(st7701->reset);
 	}
 
+	ret = of_drm_get_panel_orientation(dsi->dev.of_node, &st7701->orientation);
+	if (ret < 0)
+		return dev_err_probe(&dsi->dev, ret, "Failed to get orientation\n");
+
 	drm_panel_init(&st7701->panel, &dsi->dev, &st7701_funcs,
 		       DRM_MODE_CONNECTOR_DSI);
 
@@ -783,6 +918,7 @@ static void st7701_dsi_remove(struct mip
 
 static const struct of_device_id st7701_of_match[] = {
 	{ .compatible = "densitron,dmt028vghmcmi-1a", .data = &dmt028vghmcmi_1a_desc },
+	{ .compatible = "elida,kd50t048a", .data = &kd50t048a_desc },
 	{ .compatible = "techstar,ts8550b", .data = &ts8550b_desc },
 	{ }
 };
diff -rupN linux.orig/drivers/input/Kconfig linux/drivers/input/Kconfig
--- linux.orig/drivers/input/Kconfig	2023-10-27 21:46:02.400580110 +0000
+++ linux/drivers/input/Kconfig	2023-10-28 04:02:49.341614140 +0000
@@ -51,6 +51,19 @@ config INPUT_FF_MEMLESS
 	  To compile this driver as a module, choose M here: the
 	  module will be called ff-memless.
 
+config INPUT_POLLDEV
+	tristate "Polled input device skeleton"
+	help
+	  Say Y here if you are using a driver for an input
+	  device that periodically polls hardware state. This
+	  option is only useful for out-of-tree drivers since
+	  in-tree drivers select it automatically.
+
+	  If unsure, say N.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called input-polldev.
+
 config INPUT_SPARSEKMAP
 	tristate "Sparse keymap support library"
 	help
diff -rupN linux.orig/drivers/input/Makefile linux/drivers/input/Makefile
--- linux.orig/drivers/input/Makefile	2023-10-27 21:46:02.400580110 +0000
+++ linux/drivers/input/Makefile	2023-10-28 04:02:49.341614140 +0000
@@ -10,6 +10,7 @@ input-core-y := input.o input-compat.o i
 input-core-y += touchscreen.o
 
 obj-$(CONFIG_INPUT_FF_MEMLESS)	+= ff-memless.o
+obj-$(CONFIG_INPUT_POLLDEV)	+= input-polldev.o
 obj-$(CONFIG_INPUT_SPARSEKMAP)	+= sparse-keymap.o
 obj-$(CONFIG_INPUT_MATRIXKMAP)	+= matrix-keymap.o
 obj-$(CONFIG_INPUT_VIVALDIFMAP)	+= vivaldi-fmap.o
diff -rupN linux.orig/drivers/input/input-polldev.c linux/drivers/input/input-polldev.c
--- linux.orig/drivers/input/input-polldev.c	1970-01-01 00:00:00.000000000 +0000
+++ linux/drivers/input/input-polldev.c	2023-10-28 04:02:49.341614140 +0000
@@ -0,0 +1,362 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * Generic implementation of a polled input device
+
+ * Copyright (c) 2007 Dmitry Torokhov
+ */
+
+#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
+
+#include <linux/jiffies.h>
+#include <linux/slab.h>
+#include <linux/mutex.h>
+#include <linux/workqueue.h>
+#include <linux/module.h>
+#include <linux/input-polldev.h>
+
+MODULE_AUTHOR("Dmitry Torokhov <dtor@mail.ru>");
+MODULE_DESCRIPTION("Generic implementation of a polled input device");
+MODULE_LICENSE("GPL v2");
+
+static void input_polldev_queue_work(struct input_polled_dev *dev)
+{
+	unsigned long delay;
+
+	delay = msecs_to_jiffies(dev->poll_interval);
+	if (delay >= HZ)
+		delay = round_jiffies_relative(delay);
+
+	queue_delayed_work(system_freezable_wq, &dev->work, delay);
+}
+
+static void input_polled_device_work(struct work_struct *work)
+{
+	struct input_polled_dev *dev =
+		container_of(work, struct input_polled_dev, work.work);
+
+	dev->poll(dev);
+	input_polldev_queue_work(dev);
+}
+
+static int input_open_polled_device(struct input_dev *input)
+{
+	struct input_polled_dev *dev = input_get_drvdata(input);
+
+	if (dev->open)
+		dev->open(dev);
+
+	/* Only start polling if polling is enabled */
+	if (dev->poll_interval > 0) {
+		dev->poll(dev);
+		input_polldev_queue_work(dev);
+	}
+
+	return 0;
+}
+
+static void input_close_polled_device(struct input_dev *input)
+{
+	struct input_polled_dev *dev = input_get_drvdata(input);
+
+	cancel_delayed_work_sync(&dev->work);
+
+	if (dev->close)
+		dev->close(dev);
+}
+
+/* SYSFS interface */
+
+static ssize_t input_polldev_get_poll(struct device *dev,
+				      struct device_attribute *attr, char *buf)
+{
+	struct input_polled_dev *polldev = dev_get_drvdata(dev);
+
+	return sprintf(buf, "%d\n", polldev->poll_interval);
+}
+
+static ssize_t input_polldev_set_poll(struct device *dev,
+				struct device_attribute *attr, const char *buf,
+				size_t count)
+{
+	struct input_polled_dev *polldev = dev_get_drvdata(dev);
+	struct input_dev *input = polldev->input;
+	unsigned int interval;
+	int err;
+
+	err = kstrtouint(buf, 0, &interval);
+	if (err)
+		return err;
+
+	if (interval < polldev->poll_interval_min)
+		return -EINVAL;
+
+	if (interval > polldev->poll_interval_max)
+		return -EINVAL;
+
+	mutex_lock(&input->mutex);
+
+	polldev->poll_interval = interval;
+
+	if (input->users) {
+		cancel_delayed_work_sync(&polldev->work);
+		if (polldev->poll_interval > 0)
+			input_polldev_queue_work(polldev);
+	}
+
+	mutex_unlock(&input->mutex);
+
+	return count;
+}
+
+static DEVICE_ATTR(poll, S_IRUGO | S_IWUSR, input_polldev_get_poll,
+					    input_polldev_set_poll);
+
+
+static ssize_t input_polldev_get_max(struct device *dev,
+				     struct device_attribute *attr, char *buf)
+{
+	struct input_polled_dev *polldev = dev_get_drvdata(dev);
+
+	return sprintf(buf, "%d\n", polldev->poll_interval_max);
+}
+
+static DEVICE_ATTR(max, S_IRUGO, input_polldev_get_max, NULL);
+
+static ssize_t input_polldev_get_min(struct device *dev,
+				     struct device_attribute *attr, char *buf)
+{
+	struct input_polled_dev *polldev = dev_get_drvdata(dev);
+
+	return sprintf(buf, "%d\n", polldev->poll_interval_min);
+}
+
+static DEVICE_ATTR(min, S_IRUGO, input_polldev_get_min, NULL);
+
+static struct attribute *sysfs_attrs[] = {
+	&dev_attr_poll.attr,
+	&dev_attr_max.attr,
+	&dev_attr_min.attr,
+	NULL
+};
+
+static struct attribute_group input_polldev_attribute_group = {
+	.attrs = sysfs_attrs
+};
+
+static const struct attribute_group *input_polldev_attribute_groups[] = {
+	&input_polldev_attribute_group,
+	NULL
+};
+
+/**
+ * input_allocate_polled_device - allocate memory for polled device
+ *
+ * The function allocates memory for a polled device and also
+ * for an input device associated with this polled device.
+ */
+struct input_polled_dev *input_allocate_polled_device(void)
+{
+	struct input_polled_dev *dev;
+
+	dev = kzalloc(sizeof(struct input_polled_dev), GFP_KERNEL);
+	if (!dev)
+		return NULL;
+
+	dev->input = input_allocate_device();
+	if (!dev->input) {
+		kfree(dev);
+		return NULL;
+	}
+
+	return dev;
+}
+EXPORT_SYMBOL(input_allocate_polled_device);
+
+struct input_polled_devres {
+	struct input_polled_dev *polldev;
+};
+
+static int devm_input_polldev_match(struct device *dev, void *res, void *data)
+{
+	struct input_polled_devres *devres = res;
+
+	return devres->polldev == data;
+}
+
+static void devm_input_polldev_release(struct device *dev, void *res)
+{
+	struct input_polled_devres *devres = res;
+	struct input_polled_dev *polldev = devres->polldev;
+
+	dev_dbg(dev, "%s: dropping reference/freeing %s\n",
+		__func__, dev_name(&polldev->input->dev));
+
+	input_put_device(polldev->input);
+	kfree(polldev);
+}
+
+static void devm_input_polldev_unregister(struct device *dev, void *res)
+{
+	struct input_polled_devres *devres = res;
+	struct input_polled_dev *polldev = devres->polldev;
+
+	dev_dbg(dev, "%s: unregistering device %s\n",
+		__func__, dev_name(&polldev->input->dev));
+	input_unregister_device(polldev->input);
+
+	/*
+	 * Note that we are still holding extra reference to the input
+	 * device so it will stick around until devm_input_polldev_release()
+	 * is called.
+	 */
+}
+
+/**
+ * devm_input_allocate_polled_device - allocate managed polled device
+ * @dev: device owning the polled device being created
+ *
+ * Returns prepared &struct input_polled_dev or %NULL.
+ *
+ * Managed polled input devices do not need to be explicitly unregistered
+ * or freed as it will be done automatically when owner device unbinds
+ * from * its driver (or binding fails). Once such managed polled device
+ * is allocated, it is ready to be set up and registered in the same
+ * fashion as regular polled input devices (using
+ * input_register_polled_device() function).
+ *
+ * If you want to manually unregister and free such managed polled devices,
+ * it can be still done by calling input_unregister_polled_device() and
+ * input_free_polled_device(), although it is rarely needed.
+ *
+ * NOTE: the owner device is set up as parent of input device and users
+ * should not override it.
+ */
+struct input_polled_dev *devm_input_allocate_polled_device(struct device *dev)
+{
+	struct input_polled_dev *polldev;
+	struct input_polled_devres *devres;
+
+	devres = devres_alloc(devm_input_polldev_release, sizeof(*devres),
+			      GFP_KERNEL);
+	if (!devres)
+		return NULL;
+
+	polldev = input_allocate_polled_device();
+	if (!polldev) {
+		devres_free(devres);
+		return NULL;
+	}
+
+	polldev->input->dev.parent = dev;
+	polldev->devres_managed = true;
+
+	devres->polldev = polldev;
+	devres_add(dev, devres);
+
+	return polldev;
+}
+EXPORT_SYMBOL(devm_input_allocate_polled_device);
+
+/**
+ * input_free_polled_device - free memory allocated for polled device
+ * @dev: device to free
+ *
+ * The function frees memory allocated for polling device and drops
+ * reference to the associated input device.
+ */
+void input_free_polled_device(struct input_polled_dev *dev)
+{
+	if (dev) {
+		if (dev->devres_managed)
+			WARN_ON(devres_destroy(dev->input->dev.parent,
+						devm_input_polldev_release,
+						devm_input_polldev_match,
+						dev));
+		input_put_device(dev->input);
+		kfree(dev);
+	}
+}
+EXPORT_SYMBOL(input_free_polled_device);
+
+/**
+ * input_register_polled_device - register polled device
+ * @dev: device to register
+ *
+ * The function registers previously initialized polled input device
+ * with input layer. The device should be allocated with call to
+ * input_allocate_polled_device(). Callers should also set up poll()
+ * method and set up capabilities (id, name, phys, bits) of the
+ * corresponding input_dev structure.
+ */
+int input_register_polled_device(struct input_polled_dev *dev)
+{
+	struct input_polled_devres *devres = NULL;
+	struct input_dev *input = dev->input;
+	int error;
+
+	if (dev->devres_managed) {
+		devres = devres_alloc(devm_input_polldev_unregister,
+				      sizeof(*devres), GFP_KERNEL);
+		if (!devres)
+			return -ENOMEM;
+
+		devres->polldev = dev;
+	}
+
+	input_set_drvdata(input, dev);
+	INIT_DELAYED_WORK(&dev->work, input_polled_device_work);
+
+	if (!dev->poll_interval)
+		dev->poll_interval = 500;
+	if (!dev->poll_interval_max)
+		dev->poll_interval_max = dev->poll_interval;
+
+	input->open = input_open_polled_device;
+	input->close = input_close_polled_device;
+
+	input->dev.groups = input_polldev_attribute_groups;
+
+	error = input_register_device(input);
+	if (error) {
+		devres_free(devres);
+		return error;
+	}
+
+	/*
+	 * Take extra reference to the underlying input device so
+	 * that it survives call to input_unregister_polled_device()
+	 * and is deleted only after input_free_polled_device()
+	 * has been invoked. This is needed to ease task of freeing
+	 * sparse keymaps.
+	 */
+	input_get_device(input);
+
+	if (dev->devres_managed) {
+		dev_dbg(input->dev.parent, "%s: registering %s with devres.\n",
+			__func__, dev_name(&input->dev));
+		devres_add(input->dev.parent, devres);
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(input_register_polled_device);
+
+/**
+ * input_unregister_polled_device - unregister polled device
+ * @dev: device to unregister
+ *
+ * The function unregisters previously registered polled input
+ * device from input layer. Polling is stopped and device is
+ * ready to be freed with call to input_free_polled_device().
+ */
+void input_unregister_polled_device(struct input_polled_dev *dev)
+{
+	if (dev->devres_managed)
+		WARN_ON(devres_destroy(dev->input->dev.parent,
+					devm_input_polldev_unregister,
+					devm_input_polldev_match,
+					dev));
+
+	input_unregister_device(dev->input);
+}
+EXPORT_SYMBOL(input_unregister_polled_device);
diff -rupN linux.orig/drivers/input/joystick/Kconfig linux/drivers/input/joystick/Kconfig
--- linux.orig/drivers/input/joystick/Kconfig	2023-10-27 21:46:02.400580110 +0000
+++ linux/drivers/input/joystick/Kconfig	2023-10-28 04:02:49.341614140 +0000
@@ -400,6 +400,21 @@ config JOYSTICK_N64
 	  Say Y here if you want enable support for the four
 	  built-in controller ports on the Nintendo 64 console.
 
+config JOYSTICK_ODROIDGO2
+	tristate "ODROIDGO2-Advance joypad driver"
+	help
+	  Made for ODROIDGO2-Advance.
+
+config JOYSTICK_ODROIDGO2_V11
+        tristate "ODROIDGO2-Advance joypad driver"
+        help
+          Made for ODROIDGO2-Advance.
+
+config JOYSTICK_ODROIDGO3
+	tristate "ODROIDGO3 joypad driver"
+	help
+	  Made for ODROIDGO3.
+
 config JOYSTICK_SENSEHAT
 	tristate "Raspberry Pi Sense HAT joystick"
 	depends on INPUT && I2C
diff -rupN linux.orig/drivers/input/joystick/Makefile linux/drivers/input/joystick/Makefile
--- linux.orig/drivers/input/joystick/Makefile	2023-10-27 21:46:02.400580110 +0000
+++ linux/drivers/input/joystick/Makefile	2023-10-28 04:02:49.341614140 +0000
@@ -25,6 +25,9 @@ obj-$(CONFIG_JOYSTICK_JOYDUMP)		+= joydu
 obj-$(CONFIG_JOYSTICK_MAGELLAN)		+= magellan.o
 obj-$(CONFIG_JOYSTICK_MAPLE)		+= maplecontrol.o
 obj-$(CONFIG_JOYSTICK_N64)		+= n64joy.o
+obj-$(CONFIG_JOYSTICK_ODROIDGO2)	+= odroidgo2-joypad.o
+obj-$(CONFIG_JOYSTICK_ODROIDGO2_V11)	+= odroidgo2-v11-joypad.o
+obj-$(CONFIG_JOYSTICK_ODROIDGO3)	+= odroidgo3-joypad.o
 obj-$(CONFIG_JOYSTICK_PSXPAD_SPI)	+= psxpad-spi.o
 obj-$(CONFIG_JOYSTICK_PXRC)		+= pxrc.o
 obj-$(CONFIG_JOYSTICK_QWIIC)		+= qwiic-joystick.o
diff -rupN linux.orig/drivers/input/joystick/odroidgo2-joypad.c linux/drivers/input/joystick/odroidgo2-joypad.c
--- linux.orig/drivers/input/joystick/odroidgo2-joypad.c	1970-01-01 00:00:00.000000000 +0000
+++ linux/drivers/input/joystick/odroidgo2-joypad.c	2023-10-28 04:02:49.341614140 +0000
@@ -0,0 +1,878 @@
+/*
+ * SARADC joystick & GPIO Button driver for Linux(Hardkernel ODROIDGO2-Advance)
+ */
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ * Should you need to contact me, the author, you can do so either by
+ * e-mail - mail your message to <vojtech@ucw.cz>, or by paper mail:
+ * Vojtech Pavlik, Simunkova 1594, Prague 8, 182 00 Czech Republic
+ */
+
+/*----------------------------------------------------------------------------*/
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/input.h>
+#include <linux/input-polldev.h>
+#include <linux/ioport.h>
+#include <linux/platform_device.h>
+#include <linux/gpio.h>
+#include <linux/gpio/consumer.h>
+#include <linux/gpio_keys.h>
+#include <linux/iio/consumer.h>
+#include <linux/iio/types.h>
+#include <linux/property.h>
+#include <linux/of_gpio.h>
+
+/*----------------------------------------------------------------------------*/
+#define DRV_NAME "odroidgo2_joypad"
+
+/*----------------------------------------------------------------------------*/
+struct bt_adc {
+	/* IIO ADC Channel */
+	struct iio_channel *channel;
+	/* report value (mV) */
+	int old_value;
+	/* report type */
+	int report_type;
+	/* input device init value (mV) */
+	int max, min;
+	/* calibrated adc value */
+	int cal;
+	/*  adc scale value */
+	int scale;
+	/* invert report */
+	bool invert;
+};
+
+struct bt_gpio {
+	/* GPIO Request label */
+	const char *label;
+	/* GPIO Number */
+	int num;
+	/* report type */
+	int report_type;
+	/* report linux code */
+	int linux_code;
+	/* prev button value */
+	bool old_value;
+	/* button press level */
+	bool active_level;
+};
+
+struct joypad {
+	struct device *dev;
+	int poll_interval;
+
+	/* report enable/disable */
+	bool enable;
+
+	/* report reference point */
+	bool invert_absx;
+	bool invert_absy;
+
+	/* report interval (ms) */
+	int bt_gpio_count;
+	struct bt_gpio *gpios;
+	/* button auto repeat */
+	int auto_repeat;
+
+	/* report threshold (mV) */
+	int bt_adc_fuzz, bt_adc_flat;
+	int bt_adc_x_range, bt_adc_y_range;
+	/* adc read value scale */
+	int bt_adc_scale;
+	/* joystick deadzone control */
+	int bt_adc_deadzone;
+	int bt_adc_count;
+	struct bt_adc *adcs;
+
+	struct mutex lock;
+};
+
+/*----------------------------------------------------------------------------*/
+//
+// set to the value in the boot.ini file. (if exist)
+//
+/*----------------------------------------------------------------------------*/
+static unsigned int g_button_adc_x_range = 0;
+static unsigned int g_button_adc_y_range = 0;
+static unsigned int g_button_adc_fuzz = 0;
+static unsigned int g_button_adc_flat = 0;
+static unsigned int g_button_adc_scale = 0;
+static unsigned int g_button_adc_deadzone = 0;
+
+static int __init button_adcx_range_setup(char *str)
+{
+        if (!str)
+                return -EINVAL;
+
+	g_button_adc_x_range = simple_strtoul(str, NULL, 10);
+
+        return 0;
+}
+__setup("button-adc-x-range=", button_adcx_range_setup);
+
+static int __init button_adcy_range_setup(char *str)
+{
+        if (!str)
+                return -EINVAL;
+
+	g_button_adc_y_range = simple_strtoul(str, NULL, 10);
+
+        return 0;
+}
+__setup("button-adc-y-range=", button_adcy_range_setup);
+
+static int button_adc_fuzz(char *str)
+{
+        if (!str)
+                return -EINVAL;
+	g_button_adc_fuzz = simple_strtoul(str, NULL, 10);
+	return 0;
+}
+__setup("button-adc-fuzz=", button_adc_fuzz);
+
+static int button_adc_flat(char *str)
+{
+        if (!str)
+                return -EINVAL;
+	g_button_adc_flat = simple_strtoul(str, NULL, 10);
+	return 0;
+}
+__setup("button-adc-flat=", button_adc_flat);
+
+static int button_adc_scale(char *str)
+{
+        if (!str)
+                return -EINVAL;
+	g_button_adc_scale = simple_strtoul(str, NULL, 10);
+	return 0;
+}
+__setup("button-adc-scale=", button_adc_scale);
+
+static int button_adc_deadzone(char *str)
+{
+        if (!str)
+                return -EINVAL;
+	g_button_adc_deadzone = simple_strtoul(str, NULL, 10);
+	return 0;
+}
+__setup("button-adc-deadzone=", button_adc_deadzone);
+
+/*----------------------------------------------------------------------------*/
+/*----------------------------------------------------------------------------*/
+static int joypad_adc_read(struct bt_adc *adc)
+{
+	int value;
+
+	if (iio_read_channel_processed(adc->channel, &value))
+		return 0;
+
+	value *= adc->scale;
+
+	return (adc->invert ? (adc->max - value) : value);
+}
+
+/*----------------------------------------------------------------------------*/
+/*----------------------------------------------------------------------------*/
+/*
+ * ATTRIBUTES:
+ *
+ * /sys/devices/platform/odroidgo2_joypad/poll_interval [rw]
+ */
+/*----------------------------------------------------------------------------*/
+static ssize_t joypad_store_poll_interval(struct device *dev,
+				      struct device_attribute *attr,
+				      const char *buf,
+				      size_t count)
+{
+	struct platform_device *pdev  = to_platform_device(dev);
+	struct joypad *joypad = platform_get_drvdata(pdev);
+
+	mutex_lock(&joypad->lock);
+	joypad->poll_interval = simple_strtoul(buf, NULL, 10);
+	mutex_unlock(&joypad->lock);
+
+	return count;
+}
+
+/*----------------------------------------------------------------------------*/
+static ssize_t joypad_show_poll_interval(struct device *dev,
+				     struct device_attribute *attr,
+				     char *buf)
+{
+	struct platform_device *pdev  = to_platform_device(dev);
+	struct joypad *joypad = platform_get_drvdata(pdev);
+
+	return sprintf(buf, "%d\n", joypad->poll_interval);
+}
+
+/*----------------------------------------------------------------------------*/
+static DEVICE_ATTR(poll_interval, S_IWUSR | S_IRUGO,
+		   joypad_show_poll_interval,
+		   joypad_store_poll_interval);
+
+/*----------------------------------------------------------------------------*/
+/*
+ * ATTRIBUTES:
+ *
+ * /sys/devices/platform/odroidgo2_joypad/adc_fuzz [r]
+ */
+/*----------------------------------------------------------------------------*/
+static ssize_t joypad_show_adc_fuzz(struct device *dev,
+				     struct device_attribute *attr,
+				     char *buf)
+{
+	struct platform_device *pdev  = to_platform_device(dev);
+	struct joypad *joypad = platform_get_drvdata(pdev);
+
+	return sprintf(buf, "%d\n", joypad->bt_adc_fuzz);
+}
+
+/*----------------------------------------------------------------------------*/
+static DEVICE_ATTR(adc_fuzz, S_IWUSR | S_IRUGO,
+		   joypad_show_adc_fuzz,
+		   NULL);
+
+/*----------------------------------------------------------------------------*/
+/*
+ * ATTRIBUTES:
+ *
+ * /sys/devices/platform/odroidgo2_joypad/adc_flat [r]
+ */
+/*----------------------------------------------------------------------------*/
+static ssize_t joypad_show_adc_flat(struct device *dev,
+				     struct device_attribute *attr,
+				     char *buf)
+{
+	struct platform_device *pdev  = to_platform_device(dev);
+	struct joypad *joypad = platform_get_drvdata(pdev);
+
+	return sprintf(buf, "%d\n", joypad->bt_adc_flat);
+}
+
+/*----------------------------------------------------------------------------*/
+static DEVICE_ATTR(adc_flat, S_IWUSR | S_IRUGO,
+		   joypad_show_adc_flat,
+		   NULL);
+
+/*----------------------------------------------------------------------------*/
+/*
+ * ATTRIBUTES:
+ *
+ * /sys/devices/platform/odroidgo2_joypad/enable [rw]
+ */
+/*----------------------------------------------------------------------------*/
+static ssize_t joypad_store_enable(struct device *dev,
+				      struct device_attribute *attr,
+				      const char *buf,
+				      size_t count)
+{
+	struct platform_device *pdev  = to_platform_device(dev);
+	struct joypad *joypad = platform_get_drvdata(pdev);
+
+	mutex_lock(&joypad->lock);
+	joypad->enable = simple_strtoul(buf, NULL, 10);
+	mutex_unlock(&joypad->lock);
+
+	return count;
+}
+
+/*----------------------------------------------------------------------------*/
+static ssize_t joypad_show_enable(struct device *dev,
+				     struct device_attribute *attr,
+				     char *buf)
+{
+	struct platform_device *pdev  = to_platform_device(dev);
+	struct joypad *joypad = platform_get_drvdata(pdev);
+
+	return sprintf(buf, "%d\n", joypad->enable);
+}
+
+/*----------------------------------------------------------------------------*/
+static DEVICE_ATTR(enable, S_IWUSR | S_IRUGO,
+		   joypad_show_enable,
+		   joypad_store_enable);
+
+/*----------------------------------------------------------------------------*/
+/*
+ * ATTRIBUTES:
+ *
+ * /sys/devices/platform/odroidgo2_joypad/adc_cal [rw]
+ */
+/*----------------------------------------------------------------------------*/
+static ssize_t joypad_store_adc_cal(struct device *dev,
+				      struct device_attribute *attr,
+				      const char *buf,
+				      size_t count)
+{
+	struct platform_device *pdev  = to_platform_device(dev);
+	struct joypad *joypad = platform_get_drvdata(pdev);
+	bool calibration;
+
+	calibration = simple_strtoul(buf, NULL, 10);
+
+	if (calibration) {
+		int nbtn;
+
+		mutex_lock(&joypad->lock);
+		for (nbtn = 0; nbtn < joypad->bt_adc_count; nbtn++) {
+			struct bt_adc *adc = &joypad->adcs[nbtn];
+
+			adc->cal = joypad_adc_read(adc);
+			if (!adc->cal) {
+				dev_err(joypad->dev, "%s : saradc channels[%d]!\n",
+					__func__, nbtn);
+				continue;
+			}
+			adc->old_value = adc->cal;
+		}
+		mutex_unlock(&joypad->lock);
+	}
+	return count;
+}
+
+/*----------------------------------------------------------------------------*/
+static ssize_t joypad_show_adc_cal(struct device *dev,
+				     struct device_attribute *attr,
+				     char *buf)
+{
+	struct platform_device *pdev  = to_platform_device(dev);
+	struct joypad *joypad = platform_get_drvdata(pdev);
+	int nbtn;
+	ssize_t pos;
+
+	for (nbtn = 0, pos = 0; nbtn < joypad->bt_adc_count; nbtn++) {
+		struct bt_adc *adc = &joypad->adcs[nbtn];
+		pos += sprintf(&buf[pos], "adc[%d]->cal = %d ",
+				nbtn, adc->cal);
+	}
+	pos += sprintf(&buf[pos], "\n");
+	return pos;
+}
+
+/*----------------------------------------------------------------------------*/
+static DEVICE_ATTR(adc_cal, S_IWUSR | S_IRUGO,
+		   joypad_show_adc_cal,
+		   joypad_store_adc_cal);
+
+/*----------------------------------------------------------------------------*/
+/*----------------------------------------------------------------------------*/
+static struct attribute *joypad_attrs[] = {
+	&dev_attr_poll_interval.attr,
+	&dev_attr_adc_fuzz.attr,
+	&dev_attr_adc_flat.attr,
+	&dev_attr_enable.attr,
+	&dev_attr_adc_cal.attr,
+	NULL,
+};
+
+static struct attribute_group joypad_attr_group = {
+	.attrs = joypad_attrs,
+};
+
+/*----------------------------------------------------------------------------*/
+/*----------------------------------------------------------------------------*/
+static void joypad_gpio_check(struct input_polled_dev *poll_dev)
+{
+	struct joypad *joypad = poll_dev->private;
+	int nbtn, value;
+
+	for (nbtn = 0; nbtn < joypad->bt_gpio_count; nbtn++) {
+		struct bt_gpio *gpio = &joypad->gpios[nbtn];
+
+		if (gpio_get_value_cansleep(gpio->num) < 0) {
+			dev_err(joypad->dev, "failed to get gpio state\n");
+			continue;
+		}
+		value = gpio_get_value(gpio->num);
+		if (value != gpio->old_value) {
+			input_event(poll_dev->input,
+				gpio->report_type,
+				gpio->linux_code,
+				(value == gpio->active_level) ? 1 : 0);
+			gpio->old_value = value;
+		}
+	}
+	input_sync(poll_dev->input);
+}
+
+/*----------------------------------------------------------------------------*/
+static void joypad_adc_check(struct input_polled_dev *poll_dev)
+{
+	struct joypad *joypad = poll_dev->private;
+	int nbtn, value;
+
+	for (nbtn = 0; nbtn < joypad->bt_adc_count; nbtn++) {
+		struct bt_adc *adc = &joypad->adcs[nbtn];
+
+		value = joypad_adc_read(adc);
+		if (!value) {
+			dev_err(joypad->dev, "%s : saradc channels[%d]!\n",
+				__func__, nbtn);
+			continue;
+		}
+
+		/* Joystick Deadzone check */
+		if (joypad->bt_adc_deadzone) {
+			if ((value < adc->cal + joypad->bt_adc_deadzone) &&
+			    (value > adc->cal - joypad->bt_adc_deadzone))
+				value = adc->cal;
+		}
+		value = value - adc->cal;
+		value = value > adc->max ? adc->max : value;
+		value = value < adc->min ? adc->min : value;
+
+		if (nbtn == 0)
+		{
+			// adc-x value is default inverted(h/w)
+			input_report_abs(poll_dev->input,
+				adc->report_type, value * (-1));
+		}
+		else
+		{
+			input_report_abs(poll_dev->input,
+				adc->report_type, value);
+		}
+		adc->old_value = value;
+	}
+	input_sync(poll_dev->input);
+}
+
+/*----------------------------------------------------------------------------*/
+static void joypad_poll(struct input_polled_dev *poll_dev)
+{
+	struct joypad *joypad = poll_dev->private;
+
+	if (joypad->enable) {
+		joypad_adc_check(poll_dev);
+		joypad_gpio_check(poll_dev);
+	}
+	if (poll_dev->poll_interval != joypad->poll_interval) {
+		mutex_lock(&joypad->lock);
+		poll_dev->poll_interval = joypad->poll_interval;
+		mutex_unlock(&joypad->lock);
+	}
+}
+
+/*----------------------------------------------------------------------------*/
+static void joypad_open(struct input_polled_dev *poll_dev)
+{
+	struct joypad *joypad = poll_dev->private;
+	int nbtn;
+
+	for (nbtn = 0; nbtn < joypad->bt_gpio_count; nbtn++) {
+		struct bt_gpio *gpio = &joypad->gpios[nbtn];
+		gpio->old_value = gpio->active_level ? 0 : 1;
+	}
+	for (nbtn = 0; nbtn < joypad->bt_adc_count; nbtn++) {
+		struct bt_adc *adc = &joypad->adcs[nbtn];
+
+		adc->old_value = joypad_adc_read(adc);
+		if (!adc->old_value) {
+			dev_err(joypad->dev, "%s : saradc channels[%d]!\n",
+				__func__, nbtn);
+			continue;
+		}
+		adc->cal = adc->old_value;
+		dev_info(joypad->dev, "%s : adc[%d] adc->cal = %d\n",
+			__func__, nbtn, adc->cal);
+	}
+	/* buttons status sync */
+	joypad_adc_check(poll_dev);
+	joypad_gpio_check(poll_dev);
+
+	/* button report enable */
+	mutex_lock(&joypad->lock);
+	joypad->enable = true;
+	mutex_unlock(&joypad->lock);
+
+	dev_info(joypad->dev, "%s : opened\n", __func__);
+}
+
+/*----------------------------------------------------------------------------*/
+static void joypad_close(struct input_polled_dev *poll_dev)
+{
+	struct joypad *joypad = poll_dev->private;
+
+	/* button report disable */
+	mutex_lock(&joypad->lock);
+	joypad->enable = false;
+	mutex_unlock(&joypad->lock);
+
+	dev_info(joypad->dev, "%s : closed\n", __func__);
+}
+
+/*----------------------------------------------------------------------------*/
+static int joypad_adc_setup(struct device *dev, struct joypad *joypad)
+{
+	int nbtn = 0;
+
+	joypad->adcs = devm_kzalloc(dev, joypad->bt_adc_count *
+				sizeof(struct bt_adc), GFP_KERNEL);
+
+	if (!joypad->adcs) {
+		dev_err(dev, "%s devm_kzmalloc error!", __func__);
+		return -ENOMEM;
+	}
+
+	for (nbtn = 0; nbtn < joypad->bt_adc_count; nbtn++) {
+		struct bt_adc *adc = &joypad->adcs[nbtn];
+		enum iio_chan_type type;
+
+		adc->scale = joypad->bt_adc_scale;
+		if (nbtn) {
+			adc->channel =
+				devm_iio_channel_get(dev, "joy_y");
+			adc->report_type = ABS_Y;
+			if (joypad->invert_absy)
+				adc->invert = true;
+
+			adc->max =  (joypad->bt_adc_y_range / 2) - 1;
+			adc->min = -(joypad->bt_adc_y_range / 2);
+		}
+		else {
+			adc->channel =
+				devm_iio_channel_get(dev, "joy_x");
+			adc->report_type = ABS_X;
+			if (joypad->invert_absx)
+				adc->invert = true;
+
+			adc->max =  (joypad->bt_adc_x_range / 2) - 1;
+			adc->min = -(joypad->bt_adc_x_range / 2);
+		}
+
+		if (IS_ERR(adc->channel)) {
+			dev_err(dev, "iio channel[%d] get error\n", nbtn);
+			return -EINVAL;
+		}
+		if (!adc->channel->indio_dev)
+			return -ENXIO;
+
+		if (iio_get_channel_type(adc->channel, &type))
+			return -EINVAL;
+
+		if (type != IIO_VOLTAGE) {
+			dev_err(dev, "Incompatible channel %d type %d\n",
+				nbtn, type);
+			return -EINVAL;
+		}
+	}
+	if (nbtn == 0)
+		return -EINVAL;
+
+	return	0;
+}
+
+/*----------------------------------------------------------------------------*/
+static int joypad_gpio_setup(struct device *dev, struct joypad *joypad)
+{
+	struct device_node *node, *pp;
+	int nbtn;
+
+	node = dev->of_node;
+	if (!node)
+		return -ENODEV;
+
+	joypad->gpios = devm_kzalloc(dev, joypad->bt_gpio_count *
+				sizeof(struct bt_gpio), GFP_KERNEL);
+
+	if (!joypad->gpios) {
+		dev_err(dev, "%s devm_kzmalloc error!", __func__);
+		return -ENOMEM;
+	}
+
+	nbtn = 0;
+	for_each_child_of_node(node, pp) {
+		enum of_gpio_flags flags;
+		struct bt_gpio *gpio = &joypad->gpios[nbtn++];
+		int error;
+
+		gpio->num = of_get_gpio_flags(pp, 0, &flags);
+		if (gpio->num < 0) {
+			error = gpio->num;
+			dev_err(dev, "Failed to get gpio flags, error: %d\n",
+				error);
+			return error;
+		}
+
+		/* gpio active level(key press level) */
+		gpio->active_level = (flags & OF_GPIO_ACTIVE_LOW) ? 0 : 1;
+
+		gpio->label = of_get_property(pp, "label", NULL);
+
+		if (gpio_is_valid(gpio->num)) {
+			error = devm_gpio_request_one(dev, gpio->num,
+						      GPIOF_IN, gpio->label);
+			if (error < 0) {
+				dev_err(dev,
+					"Failed to request GPIO %d, error %d\n",
+					gpio->num, error);
+				return error;
+			}
+		}
+		if (of_property_read_u32(pp, "linux,code", &gpio->linux_code)) {
+			dev_err(dev, "Button without keycode: 0x%x\n",
+				gpio->num);
+			return -EINVAL;
+		}
+		if (of_property_read_u32(pp, "linux,input-type",
+				&gpio->report_type))
+			gpio->report_type = EV_KEY;
+	}
+	if (nbtn == 0)
+		return -EINVAL;
+
+	return	0;
+}
+
+/*----------------------------------------------------------------------------*/
+static int joypad_input_setup(struct device *dev, struct joypad *joypad)
+{
+	struct input_polled_dev *poll_dev;
+	struct input_dev *input;
+	int nbtn, error;
+
+	poll_dev = devm_input_allocate_polled_device(dev);
+	if (!poll_dev) {
+		dev_err(dev, "no memory for polled device\n");
+		return -ENOMEM;
+	}
+
+	poll_dev->private	= joypad;
+	poll_dev->poll		= joypad_poll;
+	poll_dev->poll_interval	= joypad->poll_interval;
+	poll_dev->open		= joypad_open;
+	poll_dev->close		= joypad_close;
+
+	input = poll_dev->input;
+
+	input->name = DRV_NAME;
+	input->phys = DRV_NAME"/input0";
+
+	input->id.bustype = BUS_HOST;
+	input->id.vendor  = 0x0001;
+	input->id.product = 0x0001;
+	input->id.version = 0x0101;
+
+	/* IIO ADC key setup (0 mv ~ 1800 mv) * adc->scale */
+	__set_bit(EV_ABS, input->evbit);
+	for(nbtn = 0; nbtn < joypad->bt_adc_count; nbtn++) {
+		struct bt_adc *adc = &joypad->adcs[nbtn];
+		input_set_abs_params(input, adc->report_type,
+				adc->min, adc->max,
+				joypad->bt_adc_fuzz,
+				joypad->bt_adc_flat);
+		dev_info(dev,
+			"%s : SCALE = %d, ABS min = %d, max = %d,"
+			" fuzz = %d, flat = %d, deadzone = %d\n",
+			__func__, adc->scale, adc->min, adc->max,
+			joypad->bt_adc_fuzz, joypad->bt_adc_flat,
+			joypad->bt_adc_deadzone);
+	}
+
+	/* GPIO key setup */
+	__set_bit(EV_KEY, input->evbit);
+	for(nbtn = 0; nbtn < joypad->bt_gpio_count; nbtn++) {
+		struct bt_gpio *gpio = &joypad->gpios[nbtn];
+		input_set_capability(input, gpio->report_type,
+				gpio->linux_code);
+	}
+
+	if (joypad->auto_repeat)
+		__set_bit(EV_REP, input->evbit);
+
+	joypad->dev = dev;
+
+	error = input_register_polled_device(poll_dev);
+	if (error) {
+		dev_err(dev, "unable to register polled device, err=%d\n",
+			error);
+		return error;
+	}
+	return 0;
+}
+
+/*----------------------------------------------------------------------------*/
+static void joypad_setup_value_check(struct device *dev, struct joypad *joypad)
+{
+	/*
+		fuzz: specifies fuzz value that is used to filter noise from
+			the event stream.
+	*/
+	if (g_button_adc_fuzz)
+		joypad->bt_adc_fuzz = g_button_adc_fuzz;
+	else
+		device_property_read_u32(dev, "button-adc-fuzz",
+					&joypad->bt_adc_fuzz);
+	/*
+		flat: values that are within this value will be discarded by
+			joydev interface and reported as 0 instead.
+	*/
+	if (g_button_adc_flat)
+		joypad->bt_adc_flat = g_button_adc_flat;
+	else
+		device_property_read_u32(dev, "button-adc-flat",
+					&joypad->bt_adc_flat);
+
+	/* Joystick report value control */
+	if (g_button_adc_scale)
+		joypad->bt_adc_scale = g_button_adc_scale;
+	else
+		device_property_read_u32(dev, "button-adc-scale",
+					&joypad->bt_adc_scale);
+
+	/* Joystick deadzone value control */
+	if (g_button_adc_deadzone)
+		joypad->bt_adc_deadzone = g_button_adc_deadzone;
+	else
+		device_property_read_u32(dev, "button-adc-deadzone",
+					&joypad->bt_adc_deadzone);
+
+	if (g_button_adc_x_range)
+		joypad->bt_adc_x_range = g_button_adc_x_range;
+	else
+		device_property_read_u32(dev, "button-adc-x-range",
+					&joypad->bt_adc_x_range);
+	if (g_button_adc_y_range)
+		joypad->bt_adc_y_range = g_button_adc_y_range;
+	else
+		device_property_read_u32(dev, "button-adc-y-range",
+					&joypad->bt_adc_y_range);
+}
+
+/*----------------------------------------------------------------------------*/
+static int joypad_dt_parse(struct device *dev, struct joypad *joypad)
+{
+	int error = 0;
+
+	/* initialize value check from boot.ini */
+	joypad_setup_value_check(dev, joypad);
+
+	device_property_read_u32(dev, "button-adc-count",
+				&joypad->bt_adc_count);
+
+	device_property_read_u32(dev, "poll-interval",
+				&joypad->poll_interval);
+
+	joypad->auto_repeat = device_property_present(dev, "autorepeat");
+
+	/* change the report reference point? (ADC MAX - read value) */
+	joypad->invert_absx = device_property_present(dev, "invert-absx");
+	joypad->invert_absy = device_property_present(dev, "invert-absy");
+	dev_info(dev, "%s : invert-absx = %d, inveret-absy = %d\n",
+		__func__, joypad->invert_absx, joypad->invert_absy);
+
+	joypad->bt_gpio_count = device_get_child_node_count(dev);
+
+	if ((joypad->bt_adc_count == 0) || (joypad->bt_gpio_count == 0)) {
+		dev_err(dev, "adc key = %d, gpio key = %d error!",
+			joypad->bt_adc_count, joypad->bt_gpio_count);
+		return -EINVAL;
+	}
+
+	error = joypad_adc_setup(dev, joypad);
+	if (error)
+		return error;
+
+	error = joypad_gpio_setup(dev, joypad);
+	if (error)
+		return error;
+
+	return error;
+}
+
+/*----------------------------------------------------------------------------*/
+static int joypad_probe(struct platform_device *pdev)
+{
+	struct joypad *joypad;
+	struct device *dev = &pdev->dev;
+	int error;
+
+	joypad = devm_kzalloc(dev, sizeof(struct joypad), GFP_KERNEL);
+	if (!joypad) {
+		dev_err(dev, "joypad devm_kzmalloc error!");
+		return -ENOMEM;
+	}
+
+	/* device tree data parse */
+	error = joypad_dt_parse(dev, joypad);
+	if (error) {
+		dev_err(dev, "dt parse error!(err = %d)\n", error);
+		return error;
+	}
+
+	mutex_init(&joypad->lock);
+	platform_set_drvdata(pdev, joypad);
+
+	error = sysfs_create_group(&pdev->dev.kobj, &joypad_attr_group);
+	if (error) {
+		dev_err(dev, "create sysfs group fail, error: %d\n",
+			error);
+		return error;
+	}
+
+	/* poll input device setup */
+	error = joypad_input_setup(dev, joypad);
+	if (error) {
+		dev_err(dev, "input setup failed!(err = %d)\n", error);
+		return error;
+	}
+	dev_info(dev, "%s : probe success\n", __func__);
+	return 0;
+}
+
+/*----------------------------------------------------------------------------*/
+static const struct of_device_id joypad_of_match[] = {
+	{ .compatible = "odroidgo2-joypad", },
+	{},
+};
+
+MODULE_DEVICE_TABLE(of, joypad_of_match);
+
+/*----------------------------------------------------------------------------*/
+static struct platform_driver joypad_driver = {
+	.probe = joypad_probe,
+	.driver = {
+		.name = DRV_NAME,
+		.of_match_table = of_match_ptr(joypad_of_match),
+	},
+};
+
+/*----------------------------------------------------------------------------*/
+static int __init joypad_init(void)
+{
+	return platform_driver_register(&joypad_driver);
+}
+
+/*----------------------------------------------------------------------------*/
+static void __exit joypad_exit(void)
+{
+	platform_driver_unregister(&joypad_driver);
+}
+
+/*----------------------------------------------------------------------------*/
+late_initcall(joypad_init);
+module_exit(joypad_exit);
+
+/*----------------------------------------------------------------------------*/
+MODULE_AUTHOR("Hardkernel Co.,LTD");
+MODULE_DESCRIPTION("Keypad driver(ADC&GPIO) for ODROIDGO-Advance");
+MODULE_LICENSE("GPL v2");
+MODULE_ALIAS("platform:" DRV_NAME);
+
+/*----------------------------------------------------------------------------*/
diff -rupN linux.orig/drivers/input/joystick/odroidgo2-v11-joypad.c linux/drivers/input/joystick/odroidgo2-v11-joypad.c
--- linux.orig/drivers/input/joystick/odroidgo2-v11-joypad.c	1970-01-01 00:00:00.000000000 +0000
+++ linux/drivers/input/joystick/odroidgo2-v11-joypad.c	2023-10-28 04:02:49.341614140 +0000
@@ -0,0 +1,878 @@
+/*
+ * SARADC joystick & GPIO Button driver for Linux(Hardkernel ODROIDGO2-Advance)
+ */
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ * Should you need to contact me, the author, you can do so either by
+ * e-mail - mail your message to <vojtech@ucw.cz>, or by paper mail:
+ * Vojtech Pavlik, Simunkova 1594, Prague 8, 182 00 Czech Republic
+ */
+
+/*----------------------------------------------------------------------------*/
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/input.h>
+#include <linux/input-polldev.h>
+#include <linux/ioport.h>
+#include <linux/platform_device.h>
+#include <linux/gpio.h>
+#include <linux/gpio/consumer.h>
+#include <linux/gpio_keys.h>
+#include <linux/iio/consumer.h>
+#include <linux/iio/types.h>
+#include <linux/property.h>
+#include <linux/of_gpio.h>
+
+/*----------------------------------------------------------------------------*/
+#define DRV_NAME "odroidgo2_v11_joypad"
+
+/*----------------------------------------------------------------------------*/
+struct bt_adc {
+	/* IIO ADC Channel */
+	struct iio_channel *channel;
+	/* report value (mV) */
+	int old_value;
+	/* report type */
+	int report_type;
+	/* input device init value (mV) */
+	int max, min;
+	/* calibrated adc value */
+	int cal;
+	/*  adc scale value */
+	int scale;
+	/* invert report */
+	bool invert;
+};
+
+struct bt_gpio {
+	/* GPIO Request label */
+	const char *label;
+	/* GPIO Number */
+	int num;
+	/* report type */
+	int report_type;
+	/* report linux code */
+	int linux_code;
+	/* prev button value */
+	bool old_value;
+	/* button press level */
+	bool active_level;
+};
+
+struct joypad {
+	struct device *dev;
+	int poll_interval;
+
+	/* report enable/disable */
+	bool enable;
+
+	/* report reference point */
+	bool invert_absx;
+	bool invert_absy;
+
+	/* report interval (ms) */
+	int bt_gpio_count;
+	struct bt_gpio *gpios;
+	/* button auto repeat */
+	int auto_repeat;
+
+	/* report threshold (mV) */
+	int bt_adc_fuzz, bt_adc_flat;
+	int bt_adc_x_range, bt_adc_y_range;
+	/* adc read value scale */
+	int bt_adc_scale;
+	/* joystick deadzone control */
+	int bt_adc_deadzone;
+	int bt_adc_count;
+	struct bt_adc *adcs;
+
+	struct mutex lock;
+};
+
+/*----------------------------------------------------------------------------*/
+//
+// set to the value in the boot.ini file. (if exist)
+//
+/*----------------------------------------------------------------------------*/
+static unsigned int g_button_adc_x_range = 0;
+static unsigned int g_button_adc_y_range = 0;
+static unsigned int g_button_adc_fuzz = 0;
+static unsigned int g_button_adc_flat = 0;
+static unsigned int g_button_adc_scale = 0;
+static unsigned int g_button_adc_deadzone = 0;
+
+static int __init button_adcx_range_setup(char *str)
+{
+        if (!str)
+                return -EINVAL;
+
+	g_button_adc_x_range = simple_strtoul(str, NULL, 10);
+
+        return 0;
+}
+__setup("button-adc-x-range=", button_adcx_range_setup);
+
+static int __init button_adcy_range_setup(char *str)
+{
+        if (!str)
+                return -EINVAL;
+
+	g_button_adc_y_range = simple_strtoul(str, NULL, 10);
+
+        return 0;
+}
+__setup("button-adc-y-range=", button_adcy_range_setup);
+
+static int button_adc_fuzz(char *str)
+{
+        if (!str)
+                return -EINVAL;
+	g_button_adc_fuzz = simple_strtoul(str, NULL, 10);
+	return 0;
+}
+__setup("button-adc-fuzz=", button_adc_fuzz);
+
+static int button_adc_flat(char *str)
+{
+        if (!str)
+                return -EINVAL;
+	g_button_adc_flat = simple_strtoul(str, NULL, 10);
+	return 0;
+}
+__setup("button-adc-flat=", button_adc_flat);
+
+static int button_adc_scale(char *str)
+{
+        if (!str)
+                return -EINVAL;
+	g_button_adc_scale = simple_strtoul(str, NULL, 10);
+	return 0;
+}
+__setup("button-adc-scale=", button_adc_scale);
+
+static int button_adc_deadzone(char *str)
+{
+        if (!str)
+                return -EINVAL;
+	g_button_adc_deadzone = simple_strtoul(str, NULL, 10);
+	return 0;
+}
+__setup("button-adc-deadzone=", button_adc_deadzone);
+
+/*----------------------------------------------------------------------------*/
+/*----------------------------------------------------------------------------*/
+static int joypad_adc_read(struct bt_adc *adc)
+{
+	int value;
+
+	if (iio_read_channel_processed(adc->channel, &value))
+		return 0;
+
+	value *= adc->scale;
+
+	return (adc->invert ? (adc->max - value) : value);
+}
+
+/*----------------------------------------------------------------------------*/
+/*----------------------------------------------------------------------------*/
+/*
+ * ATTRIBUTES:
+ *
+ * /sys/devices/platform/odroidgo2_joypad/poll_interval [rw]
+ */
+/*----------------------------------------------------------------------------*/
+static ssize_t joypad_store_poll_interval(struct device *dev,
+				      struct device_attribute *attr,
+				      const char *buf,
+				      size_t count)
+{
+	struct platform_device *pdev  = to_platform_device(dev);
+	struct joypad *joypad = platform_get_drvdata(pdev);
+
+	mutex_lock(&joypad->lock);
+	joypad->poll_interval = simple_strtoul(buf, NULL, 10);
+	mutex_unlock(&joypad->lock);
+
+	return count;
+}
+
+/*----------------------------------------------------------------------------*/
+static ssize_t joypad_show_poll_interval(struct device *dev,
+				     struct device_attribute *attr,
+				     char *buf)
+{
+	struct platform_device *pdev  = to_platform_device(dev);
+	struct joypad *joypad = platform_get_drvdata(pdev);
+
+	return sprintf(buf, "%d\n", joypad->poll_interval);
+}
+
+/*----------------------------------------------------------------------------*/
+static DEVICE_ATTR(poll_interval, S_IWUSR | S_IRUGO,
+		   joypad_show_poll_interval,
+		   joypad_store_poll_interval);
+
+/*----------------------------------------------------------------------------*/
+/*
+ * ATTRIBUTES:
+ *
+ * /sys/devices/platform/odroidgo2_joypad/adc_fuzz [r]
+ */
+/*----------------------------------------------------------------------------*/
+static ssize_t joypad_show_adc_fuzz(struct device *dev,
+				     struct device_attribute *attr,
+				     char *buf)
+{
+	struct platform_device *pdev  = to_platform_device(dev);
+	struct joypad *joypad = platform_get_drvdata(pdev);
+
+	return sprintf(buf, "%d\n", joypad->bt_adc_fuzz);
+}
+
+/*----------------------------------------------------------------------------*/
+static DEVICE_ATTR(adc_fuzz, S_IWUSR | S_IRUGO,
+		   joypad_show_adc_fuzz,
+		   NULL);
+
+/*----------------------------------------------------------------------------*/
+/*
+ * ATTRIBUTES:
+ *
+ * /sys/devices/platform/odroidgo2_joypad/adc_flat [r]
+ */
+/*----------------------------------------------------------------------------*/
+static ssize_t joypad_show_adc_flat(struct device *dev,
+				     struct device_attribute *attr,
+				     char *buf)
+{
+	struct platform_device *pdev  = to_platform_device(dev);
+	struct joypad *joypad = platform_get_drvdata(pdev);
+
+	return sprintf(buf, "%d\n", joypad->bt_adc_flat);
+}
+
+/*----------------------------------------------------------------------------*/
+static DEVICE_ATTR(adc_flat, S_IWUSR | S_IRUGO,
+		   joypad_show_adc_flat,
+		   NULL);
+
+/*----------------------------------------------------------------------------*/
+/*
+ * ATTRIBUTES:
+ *
+ * /sys/devices/platform/odroidgo2_joypad/enable [rw]
+ */
+/*----------------------------------------------------------------------------*/
+static ssize_t joypad_store_enable(struct device *dev,
+				      struct device_attribute *attr,
+				      const char *buf,
+				      size_t count)
+{
+	struct platform_device *pdev  = to_platform_device(dev);
+	struct joypad *joypad = platform_get_drvdata(pdev);
+
+	mutex_lock(&joypad->lock);
+	joypad->enable = simple_strtoul(buf, NULL, 10);
+	mutex_unlock(&joypad->lock);
+
+	return count;
+}
+
+/*----------------------------------------------------------------------------*/
+static ssize_t joypad_show_enable(struct device *dev,
+				     struct device_attribute *attr,
+				     char *buf)
+{
+	struct platform_device *pdev  = to_platform_device(dev);
+	struct joypad *joypad = platform_get_drvdata(pdev);
+
+	return sprintf(buf, "%d\n", joypad->enable);
+}
+
+/*----------------------------------------------------------------------------*/
+static DEVICE_ATTR(enable, S_IWUSR | S_IRUGO,
+		   joypad_show_enable,
+		   joypad_store_enable);
+
+/*----------------------------------------------------------------------------*/
+/*
+ * ATTRIBUTES:
+ *
+ * /sys/devices/platform/odroidgo2_joypad/adc_cal [rw]
+ */
+/*----------------------------------------------------------------------------*/
+static ssize_t joypad_store_adc_cal(struct device *dev,
+				      struct device_attribute *attr,
+				      const char *buf,
+				      size_t count)
+{
+	struct platform_device *pdev  = to_platform_device(dev);
+	struct joypad *joypad = platform_get_drvdata(pdev);
+	bool calibration;
+
+	calibration = simple_strtoul(buf, NULL, 10);
+
+	if (calibration) {
+		int nbtn;
+
+		mutex_lock(&joypad->lock);
+		for (nbtn = 0; nbtn < joypad->bt_adc_count; nbtn++) {
+			struct bt_adc *adc = &joypad->adcs[nbtn];
+
+			adc->cal = joypad_adc_read(adc);
+			if (!adc->cal) {
+				dev_err(joypad->dev, "%s : saradc channels[%d]!\n",
+					__func__, nbtn);
+				continue;
+			}
+			adc->old_value = adc->cal;
+		}
+		mutex_unlock(&joypad->lock);
+	}
+	return count;
+}
+
+/*----------------------------------------------------------------------------*/
+static ssize_t joypad_show_adc_cal(struct device *dev,
+				     struct device_attribute *attr,
+				     char *buf)
+{
+	struct platform_device *pdev  = to_platform_device(dev);
+	struct joypad *joypad = platform_get_drvdata(pdev);
+	int nbtn;
+	ssize_t pos;
+
+	for (nbtn = 0, pos = 0; nbtn < joypad->bt_adc_count; nbtn++) {
+		struct bt_adc *adc = &joypad->adcs[nbtn];
+		pos += sprintf(&buf[pos], "adc[%d]->cal = %d ",
+				nbtn, adc->cal);
+	}
+	pos += sprintf(&buf[pos], "\n");
+	return pos;
+}
+
+/*----------------------------------------------------------------------------*/
+static DEVICE_ATTR(adc_cal, S_IWUSR | S_IRUGO,
+		   joypad_show_adc_cal,
+		   joypad_store_adc_cal);
+
+/*----------------------------------------------------------------------------*/
+/*----------------------------------------------------------------------------*/
+static struct attribute *joypad_attrs[] = {
+	&dev_attr_poll_interval.attr,
+	&dev_attr_adc_fuzz.attr,
+	&dev_attr_adc_flat.attr,
+	&dev_attr_enable.attr,
+	&dev_attr_adc_cal.attr,
+	NULL,
+};
+
+static struct attribute_group joypad_attr_group = {
+	.attrs = joypad_attrs,
+};
+
+/*----------------------------------------------------------------------------*/
+/*----------------------------------------------------------------------------*/
+static void joypad_gpio_check(struct input_polled_dev *poll_dev)
+{
+	struct joypad *joypad = poll_dev->private;
+	int nbtn, value;
+
+	for (nbtn = 0; nbtn < joypad->bt_gpio_count; nbtn++) {
+		struct bt_gpio *gpio = &joypad->gpios[nbtn];
+
+		if (gpio_get_value_cansleep(gpio->num) < 0) {
+			dev_err(joypad->dev, "failed to get gpio state\n");
+			continue;
+		}
+		value = gpio_get_value(gpio->num);
+		if (value != gpio->old_value) {
+			input_event(poll_dev->input,
+				gpio->report_type,
+				gpio->linux_code,
+				(value == gpio->active_level) ? 1 : 0);
+			gpio->old_value = value;
+		}
+	}
+	input_sync(poll_dev->input);
+}
+
+/*----------------------------------------------------------------------------*/
+static void joypad_adc_check(struct input_polled_dev *poll_dev)
+{
+	struct joypad *joypad = poll_dev->private;
+	int nbtn, value;
+
+	for (nbtn = 0; nbtn < joypad->bt_adc_count; nbtn++) {
+		struct bt_adc *adc = &joypad->adcs[nbtn];
+
+		value = joypad_adc_read(adc);
+		if (!value) {
+			dev_err(joypad->dev, "%s : saradc channels[%d]!\n",
+				__func__, nbtn);
+			continue;
+		}
+
+		/* Joystick Deadzone check */
+		if (joypad->bt_adc_deadzone) {
+			if ((value < adc->cal + joypad->bt_adc_deadzone) &&
+			    (value > adc->cal - joypad->bt_adc_deadzone))
+				value = adc->cal;
+		}
+		value = value - adc->cal;
+		value = value > adc->max ? adc->max : value;
+		value = value < adc->min ? adc->min : value;
+
+		if (nbtn == 0)
+		{
+			// adc-x value is default inverted(h/w)
+			input_report_abs(poll_dev->input,
+				adc->report_type, value * (-1));
+		}
+		else
+		{
+			input_report_abs(poll_dev->input,
+				adc->report_type, value);
+		}
+		adc->old_value = value;
+	}
+	input_sync(poll_dev->input);
+}
+
+/*----------------------------------------------------------------------------*/
+static void joypad_poll(struct input_polled_dev *poll_dev)
+{
+	struct joypad *joypad = poll_dev->private;
+
+	if (joypad->enable) {
+		joypad_adc_check(poll_dev);
+		joypad_gpio_check(poll_dev);
+	}
+	if (poll_dev->poll_interval != joypad->poll_interval) {
+		mutex_lock(&joypad->lock);
+		poll_dev->poll_interval = joypad->poll_interval;
+		mutex_unlock(&joypad->lock);
+	}
+}
+
+/*----------------------------------------------------------------------------*/
+static void joypad_open(struct input_polled_dev *poll_dev)
+{
+	struct joypad *joypad = poll_dev->private;
+	int nbtn;
+
+	for (nbtn = 0; nbtn < joypad->bt_gpio_count; nbtn++) {
+		struct bt_gpio *gpio = &joypad->gpios[nbtn];
+		gpio->old_value = gpio->active_level ? 0 : 1;
+	}
+	for (nbtn = 0; nbtn < joypad->bt_adc_count; nbtn++) {
+		struct bt_adc *adc = &joypad->adcs[nbtn];
+
+		adc->old_value = joypad_adc_read(adc);
+		if (!adc->old_value) {
+			dev_err(joypad->dev, "%s : saradc channels[%d]!\n",
+				__func__, nbtn);
+			continue;
+		}
+		adc->cal = adc->old_value;
+		dev_info(joypad->dev, "%s : adc[%d] adc->cal = %d\n",
+			__func__, nbtn, adc->cal);
+	}
+	/* buttons status sync */
+	joypad_adc_check(poll_dev);
+	joypad_gpio_check(poll_dev);
+
+	/* button report enable */
+	mutex_lock(&joypad->lock);
+	joypad->enable = true;
+	mutex_unlock(&joypad->lock);
+
+	dev_info(joypad->dev, "%s : opened\n", __func__);
+}
+
+/*----------------------------------------------------------------------------*/
+static void joypad_close(struct input_polled_dev *poll_dev)
+{
+	struct joypad *joypad = poll_dev->private;
+
+	/* button report disable */
+	mutex_lock(&joypad->lock);
+	joypad->enable = false;
+	mutex_unlock(&joypad->lock);
+
+	dev_info(joypad->dev, "%s : closed\n", __func__);
+}
+
+/*----------------------------------------------------------------------------*/
+static int joypad_adc_setup(struct device *dev, struct joypad *joypad)
+{
+	int nbtn = 0;
+
+	joypad->adcs = devm_kzalloc(dev, joypad->bt_adc_count *
+				sizeof(struct bt_adc), GFP_KERNEL);
+
+	if (!joypad->adcs) {
+		dev_err(dev, "%s devm_kzmalloc error!", __func__);
+		return -ENOMEM;
+	}
+
+	for (nbtn = 0; nbtn < joypad->bt_adc_count; nbtn++) {
+		struct bt_adc *adc = &joypad->adcs[nbtn];
+		enum iio_chan_type type;
+
+		adc->scale = joypad->bt_adc_scale;
+		if (nbtn) {
+			adc->channel =
+				devm_iio_channel_get(dev, "joy_y");
+			adc->report_type = ABS_Y;
+			if (joypad->invert_absy)
+				adc->invert = true;
+
+			adc->max =  (joypad->bt_adc_y_range / 2) - 1;
+			adc->min = -(joypad->bt_adc_y_range / 2);
+		}
+		else {
+			adc->channel =
+				devm_iio_channel_get(dev, "joy_x");
+			adc->report_type = ABS_X;
+			if (joypad->invert_absx)
+				adc->invert = true;
+
+			adc->max =  (joypad->bt_adc_x_range / 2) - 1;
+			adc->min = -(joypad->bt_adc_x_range / 2);
+		}
+
+		if (IS_ERR(adc->channel)) {
+			dev_err(dev, "iio channel[%d] get error\n", nbtn);
+			return -EINVAL;
+		}
+		if (!adc->channel->indio_dev)
+			return -ENXIO;
+
+		if (iio_get_channel_type(adc->channel, &type))
+			return -EINVAL;
+
+		if (type != IIO_VOLTAGE) {
+			dev_err(dev, "Incompatible channel %d type %d\n",
+				nbtn, type);
+			return -EINVAL;
+		}
+	}
+	if (nbtn == 0)
+		return -EINVAL;
+
+	return	0;
+}
+
+/*----------------------------------------------------------------------------*/
+static int joypad_gpio_setup(struct device *dev, struct joypad *joypad)
+{
+	struct device_node *node, *pp;
+	int nbtn;
+
+	node = dev->of_node;
+	if (!node)
+		return -ENODEV;
+
+	joypad->gpios = devm_kzalloc(dev, joypad->bt_gpio_count *
+				sizeof(struct bt_gpio), GFP_KERNEL);
+
+	if (!joypad->gpios) {
+		dev_err(dev, "%s devm_kzmalloc error!", __func__);
+		return -ENOMEM;
+	}
+
+	nbtn = 0;
+	for_each_child_of_node(node, pp) {
+		enum of_gpio_flags flags;
+		struct bt_gpio *gpio = &joypad->gpios[nbtn++];
+		int error;
+
+		gpio->num = of_get_gpio_flags(pp, 0, &flags);
+		if (gpio->num < 0) {
+			error = gpio->num;
+			dev_err(dev, "Failed to get gpio flags, error: %d\n",
+				error);
+			return error;
+		}
+
+		/* gpio active level(key press level) */
+		gpio->active_level = (flags & OF_GPIO_ACTIVE_LOW) ? 0 : 1;
+
+		gpio->label = of_get_property(pp, "label", NULL);
+
+		if (gpio_is_valid(gpio->num)) {
+			error = devm_gpio_request_one(dev, gpio->num,
+						      GPIOF_IN, gpio->label);
+			if (error < 0) {
+				dev_err(dev,
+					"Failed to request GPIO %d, error %d\n",
+					gpio->num, error);
+				return error;
+			}
+		}
+		if (of_property_read_u32(pp, "linux,code", &gpio->linux_code)) {
+			dev_err(dev, "Button without keycode: 0x%x\n",
+				gpio->num);
+			return -EINVAL;
+		}
+		if (of_property_read_u32(pp, "linux,input-type",
+				&gpio->report_type))
+			gpio->report_type = EV_KEY;
+	}
+	if (nbtn == 0)
+		return -EINVAL;
+
+	return	0;
+}
+
+/*----------------------------------------------------------------------------*/
+static int joypad_input_setup(struct device *dev, struct joypad *joypad)
+{
+	struct input_polled_dev *poll_dev;
+	struct input_dev *input;
+	int nbtn, error;
+
+	poll_dev = devm_input_allocate_polled_device(dev);
+	if (!poll_dev) {
+		dev_err(dev, "no memory for polled device\n");
+		return -ENOMEM;
+	}
+
+	poll_dev->private	= joypad;
+	poll_dev->poll		= joypad_poll;
+	poll_dev->poll_interval	= joypad->poll_interval;
+	poll_dev->open		= joypad_open;
+	poll_dev->close		= joypad_close;
+
+	input = poll_dev->input;
+
+	input->name = DRV_NAME;
+	input->phys = DRV_NAME"/input0";
+
+	input->id.bustype = BUS_HOST;
+	input->id.vendor  = 0x0001;
+	input->id.product = 0x0002;
+	input->id.version = 0x0101;
+
+	/* IIO ADC key setup (0 mv ~ 1800 mv) * adc->scale */
+	__set_bit(EV_ABS, input->evbit);
+	for(nbtn = 0; nbtn < joypad->bt_adc_count; nbtn++) {
+		struct bt_adc *adc = &joypad->adcs[nbtn];
+		input_set_abs_params(input, adc->report_type,
+				adc->min, adc->max,
+				joypad->bt_adc_fuzz,
+				joypad->bt_adc_flat);
+		dev_info(dev,
+			"%s : SCALE = %d, ABS min = %d, max = %d,"
+			" fuzz = %d, flat = %d, deadzone = %d\n",
+			__func__, adc->scale, adc->min, adc->max,
+			joypad->bt_adc_fuzz, joypad->bt_adc_flat,
+			joypad->bt_adc_deadzone);
+	}
+
+	/* GPIO key setup */
+	__set_bit(EV_KEY, input->evbit);
+	for(nbtn = 0; nbtn < joypad->bt_gpio_count; nbtn++) {
+		struct bt_gpio *gpio = &joypad->gpios[nbtn];
+		input_set_capability(input, gpio->report_type,
+				gpio->linux_code);
+	}
+
+	if (joypad->auto_repeat)
+		__set_bit(EV_REP, input->evbit);
+
+	joypad->dev = dev;
+
+	error = input_register_polled_device(poll_dev);
+	if (error) {
+		dev_err(dev, "unable to register polled device, err=%d\n",
+			error);
+		return error;
+	}
+	return 0;
+}
+
+/*----------------------------------------------------------------------------*/
+static void joypad_setup_value_check(struct device *dev, struct joypad *joypad)
+{
+	/*
+		fuzz: specifies fuzz value that is used to filter noise from
+			the event stream.
+	*/
+	if (g_button_adc_fuzz)
+		joypad->bt_adc_fuzz = g_button_adc_fuzz;
+	else
+		device_property_read_u32(dev, "button-adc-fuzz",
+					&joypad->bt_adc_fuzz);
+	/*
+		flat: values that are within this value will be discarded by
+			joydev interface and reported as 0 instead.
+	*/
+	if (g_button_adc_flat)
+		joypad->bt_adc_flat = g_button_adc_flat;
+	else
+		device_property_read_u32(dev, "button-adc-flat",
+					&joypad->bt_adc_flat);
+
+	/* Joystick report value control */
+	if (g_button_adc_scale)
+		joypad->bt_adc_scale = g_button_adc_scale;
+	else
+		device_property_read_u32(dev, "button-adc-scale",
+					&joypad->bt_adc_scale);
+
+	/* Joystick deadzone value control */
+	if (g_button_adc_deadzone)
+		joypad->bt_adc_deadzone = g_button_adc_deadzone;
+	else
+		device_property_read_u32(dev, "button-adc-deadzone",
+					&joypad->bt_adc_deadzone);
+
+	if (g_button_adc_x_range)
+		joypad->bt_adc_x_range = g_button_adc_x_range;
+	else
+		device_property_read_u32(dev, "button-adc-x-range",
+					&joypad->bt_adc_x_range);
+	if (g_button_adc_y_range)
+		joypad->bt_adc_y_range = g_button_adc_y_range;
+	else
+		device_property_read_u32(dev, "button-adc-y-range",
+					&joypad->bt_adc_y_range);
+}
+
+/*----------------------------------------------------------------------------*/
+static int joypad_dt_parse(struct device *dev, struct joypad *joypad)
+{
+	int error = 0;
+
+	/* initialize value check from boot.ini */
+	joypad_setup_value_check(dev, joypad);
+
+	device_property_read_u32(dev, "button-adc-count",
+				&joypad->bt_adc_count);
+
+	device_property_read_u32(dev, "poll-interval",
+				&joypad->poll_interval);
+
+	joypad->auto_repeat = device_property_present(dev, "autorepeat");
+
+	/* change the report reference point? (ADC MAX - read value) */
+	joypad->invert_absx = device_property_present(dev, "invert-absx");
+	joypad->invert_absy = device_property_present(dev, "invert-absy");
+	dev_info(dev, "%s : invert-absx = %d, inveret-absy = %d\n",
+		__func__, joypad->invert_absx, joypad->invert_absy);
+
+	joypad->bt_gpio_count = device_get_child_node_count(dev);
+
+	if ((joypad->bt_adc_count == 0) || (joypad->bt_gpio_count == 0)) {
+		dev_err(dev, "adc key = %d, gpio key = %d error!",
+			joypad->bt_adc_count, joypad->bt_gpio_count);
+		return -EINVAL;
+	}
+
+	error = joypad_adc_setup(dev, joypad);
+	if (error)
+		return error;
+
+	error = joypad_gpio_setup(dev, joypad);
+	if (error)
+		return error;
+
+	return error;
+}
+
+/*----------------------------------------------------------------------------*/
+static int joypad_probe(struct platform_device *pdev)
+{
+	struct joypad *joypad;
+	struct device *dev = &pdev->dev;
+	int error;
+
+	joypad = devm_kzalloc(dev, sizeof(struct joypad), GFP_KERNEL);
+	if (!joypad) {
+		dev_err(dev, "joypad devm_kzmalloc error!");
+		return -ENOMEM;
+	}
+
+	/* device tree data parse */
+	error = joypad_dt_parse(dev, joypad);
+	if (error) {
+		dev_err(dev, "dt parse error!(err = %d)\n", error);
+		return error;
+	}
+
+	mutex_init(&joypad->lock);
+	platform_set_drvdata(pdev, joypad);
+
+	error = sysfs_create_group(&pdev->dev.kobj, &joypad_attr_group);
+	if (error) {
+		dev_err(dev, "create sysfs group fail, error: %d\n",
+			error);
+		return error;
+	}
+
+	/* poll input device setup */
+	error = joypad_input_setup(dev, joypad);
+	if (error) {
+		dev_err(dev, "input setup failed!(err = %d)\n", error);
+		return error;
+	}
+	dev_info(dev, "%s : probe success\n", __func__);
+	return 0;
+}
+
+/*----------------------------------------------------------------------------*/
+static const struct of_device_id joypad_of_match[] = {
+	{ .compatible = "odroidgo2-v11-joypad", },
+	{},
+};
+
+MODULE_DEVICE_TABLE(of, joypad_of_match);
+
+/*----------------------------------------------------------------------------*/
+static struct platform_driver joypad_driver = {
+	.probe = joypad_probe,
+	.driver = {
+		.name = DRV_NAME,
+		.of_match_table = of_match_ptr(joypad_of_match),
+	},
+};
+
+/*----------------------------------------------------------------------------*/
+static int __init joypad_init(void)
+{
+	return platform_driver_register(&joypad_driver);
+}
+
+/*----------------------------------------------------------------------------*/
+static void __exit joypad_exit(void)
+{
+	platform_driver_unregister(&joypad_driver);
+}
+
+/*----------------------------------------------------------------------------*/
+late_initcall(joypad_init);
+module_exit(joypad_exit);
+
+/*----------------------------------------------------------------------------*/
+MODULE_AUTHOR("Hardkernel Co.,LTD");
+MODULE_DESCRIPTION("Keypad driver(ADC&GPIO) for ODROIDGO-Advance");
+MODULE_LICENSE("GPL v2");
+MODULE_ALIAS("platform:" DRV_NAME);
+
+/*----------------------------------------------------------------------------*/
diff -rupN linux.orig/drivers/input/joystick/odroidgo3-joypad.c linux/drivers/input/joystick/odroidgo3-joypad.c
--- linux.orig/drivers/input/joystick/odroidgo3-joypad.c	1970-01-01 00:00:00.000000000 +0000
+++ linux/drivers/input/joystick/odroidgo3-joypad.c	2023-10-28 04:02:49.341614140 +0000
@@ -0,0 +1,1086 @@
+/*
+ * SARADC joystick & GPIO Button driver for Linux(Hardkernel ODROIDGO2-Advance)
+ */
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ * Should you need to contact me, the author, you can do so either by
+ * e-mail - mail your message to <vojtech@ucw.cz>, or by paper mail:
+ * Vojtech Pavlik, Simunkova 1594, Prague 8, 182 00 Czech Republic
+ */
+
+/*----------------------------------------------------------------------------*/
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/input.h>
+#include <linux/input-polldev.h>
+#include <linux/ioport.h>
+#include <linux/platform_device.h>
+#include <linux/gpio.h>
+#include <linux/gpio/consumer.h>
+#include <linux/gpio_keys.h>
+#include <linux/iio/consumer.h>
+#include <linux/iio/types.h>
+#include <linux/property.h>
+#include <linux/of_gpio.h>
+#include <linux/delay.h>
+
+/*----------------------------------------------------------------------------*/
+#define DRV_NAME "odroidgo3_joypad"
+
+/*----------------------------------------------------------------------------*/
+#define	ADC_MAX_VOLTAGE		1800
+#define	ADC_DATA_TUNING(x, p)	((x * p) / 100)
+#define	ADC_TUNING_DEFAULT	180
+
+/*----------------------------------------------------------------------------*/
+/*
+	+--------------------------------+
+	| IIO Channel : ADC_IN1          |
+	+--------------+-----------------+-----------------+--------+---------+
+	| EN(GPIO3.B5) | SEL_A(GPIO3.B3) | SEL_B(GPIO3.B0) | SELECT |  EVENT  |
+	+--------------+-----------------+-----------------+--------+---------+
+	|      0       |        0        |         0       |  R-Y   | ABS_RY  |
+	+--------------+-----------------+-----------------+--------+---------+
+	|      0       |        0        |         1       |  R-X   | ABS_RX  |
+	+--------------+-----------------+-----------------+--------+---------+
+	|      0       |        1        |         0       |  L-Y   |  ABS_Y  |
+	+--------------+-----------------+-----------------+--------+---------+
+	|      0       |        1        |         1       |  L-X   |  ABS_X  |
+	+--------------+-----------------+-----------------+--------+---------+
+	|      1       |        X        |         X       |  XXXX  |
+	+--------------+-----------------+-----------------+--------+
+*/
+/*----------------------------------------------------------------------------*/
+struct bt_adc {
+	/* report value (mV) */
+	int value;
+	/* report type */
+	int report_type;
+	/* input device init value (mV) */
+	int max, min;
+	/* calibrated adc value */
+	int cal;
+	/*  adc scale value */
+	int scale;
+	/* invert report */
+	bool invert;
+	/* amux channel */
+	int amux_ch;
+	/* adc data tuning value([percent), p = positive, n = negative */
+	int tuning_p, tuning_n;
+};
+
+struct analog_mux {
+	/* IIO ADC Channel : amux connect channel */
+	struct iio_channel *iio_ch;
+	/* analog mux select(a,b) gpio */
+	int sel_a_gpio, sel_b_gpio;
+	/* analog mux enable gpio */
+	int en_gpio;
+};
+
+struct bt_gpio {
+	/* GPIO Request label */
+	const char *label;
+	/* GPIO Number */
+	int num;
+	/* report type */
+	int report_type;
+	/* report linux code */
+	int linux_code;
+	/* prev button value */
+	bool old_value;
+	/* button press level */
+	bool active_level;
+};
+
+struct joypad {
+	struct device *dev;
+	int poll_interval;
+
+	/* report enable/disable */
+	bool enable;
+
+	/* analog mux & joystick control */
+	struct analog_mux *amux;
+	/* analog mux max count */
+	int amux_count;
+	/* analog button */
+	struct bt_adc *adcs;
+
+	/* report interval (ms) */
+	int bt_gpio_count;
+	struct bt_gpio *gpios;
+
+	/* button auto repeat */
+	int auto_repeat;
+
+	/* report threshold (mV) */
+	int bt_adc_fuzz, bt_adc_flat;
+	/* adc read value scale */
+	int bt_adc_scale;
+	/* joystick deadzone control */
+	int bt_adc_deadzone;
+
+	struct mutex lock;
+
+	/* amux debug channel */
+	int debug_ch;
+};
+
+/*----------------------------------------------------------------------------*/
+//
+// set to the value in the boot.ini file. (if exist)
+//
+/*----------------------------------------------------------------------------*/
+static unsigned int g_button_adc_fuzz = 0;
+static unsigned int g_button_adc_flat = 0;
+static unsigned int g_button_adc_scale = 0;
+static unsigned int g_button_adc_deadzone = 0;
+
+static int button_adc_fuzz(char *str)
+{
+	if (!str)
+		return -EINVAL;
+	g_button_adc_fuzz = simple_strtoul(str, NULL, 10);
+	return 0;
+}
+__setup("button-adc-fuzz=", button_adc_fuzz);
+
+static int button_adc_flat(char *str)
+{
+	if (!str)
+		return -EINVAL;
+	g_button_adc_flat = simple_strtoul(str, NULL, 10);
+	return 0;
+}
+__setup("button-adc-flat=", button_adc_flat);
+
+static int button_adc_scale(char *str)
+{
+	if (!str)
+		return -EINVAL;
+	g_button_adc_scale = simple_strtoul(str, NULL, 10);
+	return 0;
+}
+__setup("button-adc-scale=", button_adc_scale);
+
+static int button_adc_deadzone(char *str)
+{
+	if (!str)
+		return -EINVAL;
+	g_button_adc_deadzone = simple_strtoul(str, NULL, 10);
+	return 0;
+}
+__setup("button-adc-deadzone=", button_adc_deadzone);
+
+/*----------------------------------------------------------------------------*/
+/*----------------------------------------------------------------------------*/
+static int joypad_amux_select(struct analog_mux *amux, int channel)
+{
+	/* select mux channel */
+	gpio_set_value(amux->en_gpio, 0);
+
+	switch(channel) {
+		case 0:	/* EVENT (ABS_RY) */
+			gpio_set_value(amux->sel_a_gpio, 0);
+			gpio_set_value(amux->sel_b_gpio, 0);
+			break;
+		case 1:	/* EVENT (ABS_RX) */
+			gpio_set_value(amux->sel_a_gpio, 0);
+			gpio_set_value(amux->sel_b_gpio, 1);
+			break;
+		case 2:	/* EVENT (ABS_Y) */
+			gpio_set_value(amux->sel_a_gpio, 1);
+			gpio_set_value(amux->sel_b_gpio, 0);
+			break;
+		case 3:	/* EVENT (ABS_X) */
+			gpio_set_value(amux->sel_a_gpio, 1);
+			gpio_set_value(amux->sel_b_gpio, 1);
+			break;
+		default:
+			/* amux disanle */
+			gpio_set_value(amux->en_gpio, 1);
+			return -1;
+	}
+	/* mux swtiching speed : 35ns(on) / 9ns(off) */
+	usleep_range(1, 2);
+	return 0;
+}
+
+/*----------------------------------------------------------------------------*/
+static int joypad_adc_read(struct analog_mux *amux, struct bt_adc *adc)
+{
+	int value;
+
+	if (joypad_amux_select(amux, adc->amux_ch))
+		return 0;
+
+	if (iio_read_channel_processed(amux->iio_ch, &value))
+		return 0;
+
+	value *= adc->scale;
+
+	return (adc->invert ? (adc->max - value) : value);
+}
+
+/*----------------------------------------------------------------------------*/
+/*----------------------------------------------------------------------------*/
+/*
+ * ATTRIBUTES:
+ *
+ * /sys/devices/platform/odroidgo2_joypad/poll_interval [rw]
+ */
+/*----------------------------------------------------------------------------*/
+static ssize_t joypad_store_poll_interval(struct device *dev,
+				      struct device_attribute *attr,
+				      const char *buf,
+				      size_t count)
+{
+	struct platform_device *pdev  = to_platform_device(dev);
+	struct joypad *joypad = platform_get_drvdata(pdev);
+
+	mutex_lock(&joypad->lock);
+	joypad->poll_interval = simple_strtoul(buf, NULL, 10);
+	mutex_unlock(&joypad->lock);
+
+	return count;
+}
+
+/*----------------------------------------------------------------------------*/
+static ssize_t joypad_show_poll_interval(struct device *dev,
+				     struct device_attribute *attr,
+				     char *buf)
+{
+	struct platform_device *pdev  = to_platform_device(dev);
+	struct joypad *joypad = platform_get_drvdata(pdev);
+
+	return sprintf(buf, "%d\n", joypad->poll_interval);
+}
+
+/*----------------------------------------------------------------------------*/
+static DEVICE_ATTR(poll_interval, S_IWUSR | S_IRUGO,
+		   joypad_show_poll_interval,
+		   joypad_store_poll_interval);
+
+/*----------------------------------------------------------------------------*/
+/*
+ * ATTRIBUTES:
+ *
+ * /sys/devices/platform/odroidgo2_joypad/adc_fuzz [r]
+ */
+/*----------------------------------------------------------------------------*/
+static ssize_t joypad_show_adc_fuzz(struct device *dev,
+				     struct device_attribute *attr,
+				     char *buf)
+{
+	struct platform_device *pdev  = to_platform_device(dev);
+	struct joypad *joypad = platform_get_drvdata(pdev);
+
+	return sprintf(buf, "%d\n", joypad->bt_adc_fuzz);
+}
+
+/*----------------------------------------------------------------------------*/
+static DEVICE_ATTR(adc_fuzz, S_IWUSR | S_IRUGO,
+		   joypad_show_adc_fuzz,
+		   NULL);
+
+/*----------------------------------------------------------------------------*/
+/*
+ * ATTRIBUTES:
+ *
+ * /sys/devices/platform/odroidgo2_joypad/adc_flat [r]
+ */
+/*----------------------------------------------------------------------------*/
+static ssize_t joypad_show_adc_flat(struct device *dev,
+				     struct device_attribute *attr,
+				     char *buf)
+{
+	struct platform_device *pdev  = to_platform_device(dev);
+	struct joypad *joypad = platform_get_drvdata(pdev);
+
+	return sprintf(buf, "%d\n", joypad->bt_adc_flat);
+}
+
+/*----------------------------------------------------------------------------*/
+static DEVICE_ATTR(adc_flat, S_IWUSR | S_IRUGO,
+		   joypad_show_adc_flat,
+		   NULL);
+
+/*----------------------------------------------------------------------------*/
+/*
+ * ATTRIBUTES:
+ *
+ * /sys/devices/platform/odroidgo2_joypad/enable [rw]
+ */
+/*----------------------------------------------------------------------------*/
+static ssize_t joypad_store_enable(struct device *dev,
+				      struct device_attribute *attr,
+				      const char *buf,
+				      size_t count)
+{
+	struct platform_device *pdev  = to_platform_device(dev);
+	struct joypad *joypad = platform_get_drvdata(pdev);
+
+	mutex_lock(&joypad->lock);
+	joypad->enable = simple_strtoul(buf, NULL, 10);
+	mutex_unlock(&joypad->lock);
+
+	return count;
+}
+
+/*----------------------------------------------------------------------------*/
+static ssize_t joypad_show_enable(struct device *dev,
+				     struct device_attribute *attr,
+				     char *buf)
+{
+	struct platform_device *pdev  = to_platform_device(dev);
+	struct joypad *joypad = platform_get_drvdata(pdev);
+
+	return sprintf(buf, "%d\n", joypad->enable);
+}
+
+/*----------------------------------------------------------------------------*/
+static DEVICE_ATTR(enable, S_IWUSR | S_IRUGO,
+		   joypad_show_enable,
+		   joypad_store_enable);
+
+/*----------------------------------------------------------------------------*/
+/*
+ * ATTRIBUTES:
+ *
+ * /sys/devices/platform/odroidgo2_joypad/adc_cal [rw]
+ */
+/*----------------------------------------------------------------------------*/
+static ssize_t joypad_store_adc_cal(struct device *dev,
+				      struct device_attribute *attr,
+				      const char *buf,
+				      size_t count)
+{
+	struct platform_device *pdev  = to_platform_device(dev);
+	struct joypad *joypad = platform_get_drvdata(pdev);
+	bool calibration;
+
+	calibration = simple_strtoul(buf, NULL, 10);
+
+	if (calibration) {
+		int nbtn;
+
+		mutex_lock(&joypad->lock);
+		for (nbtn = 0; nbtn < joypad->amux_count; nbtn++) {
+			struct bt_adc *adc = &joypad->adcs[nbtn];
+
+			adc->value = joypad_adc_read(joypad->amux, adc);
+			if (!adc->value) {
+				dev_err(joypad->dev, "%s : saradc channels[%d]!\n",
+					__func__, nbtn);
+				continue;
+			}
+			adc->cal = adc->value;
+		}
+		mutex_unlock(&joypad->lock);
+	}
+	return count;
+}
+
+/*----------------------------------------------------------------------------*/
+static ssize_t joypad_show_adc_cal(struct device *dev,
+				     struct device_attribute *attr,
+				     char *buf)
+{
+	struct platform_device *pdev  = to_platform_device(dev);
+	struct joypad *joypad = platform_get_drvdata(pdev);
+	int nbtn;
+	ssize_t pos;
+
+	for (nbtn = 0, pos = 0; nbtn < joypad->amux_count; nbtn++) {
+		struct bt_adc *adc = &joypad->adcs[nbtn];
+		pos += sprintf(&buf[pos], "adc[%d]->cal = %d\n",
+				nbtn, adc->cal);
+	}
+	pos += sprintf(&buf[pos], "adc scale = %d\n", joypad->bt_adc_scale);
+	return pos;
+}
+
+/*----------------------------------------------------------------------------*/
+static DEVICE_ATTR(adc_cal, S_IWUSR | S_IRUGO,
+		   joypad_show_adc_cal,
+		   joypad_store_adc_cal);
+
+/*----------------------------------------------------------------------------*/
+/*
+ * ATTRIBUTES:
+ *
+ * /sys/devices/platform/odroidgo2_joypad/amux_debug [rw]
+ *
+ * echo [debug channel] > amux_debug
+ * cat amux_debug : debug channel mux set & adc read
+ */
+/*----------------------------------------------------------------------------*/
+static ssize_t joypad_store_amux_debug(struct device *dev,
+				      struct device_attribute *attr,
+				      const char *buf,
+				      size_t count)
+{
+	struct platform_device *pdev  = to_platform_device(dev);
+	struct joypad *joypad = platform_get_drvdata(pdev);
+
+	joypad->debug_ch = simple_strtoul(buf, NULL, 10);
+
+	/* if error than default setting(debug_ch = 0) */
+	if (joypad->debug_ch > joypad->amux_count)
+		joypad->debug_ch = 0;
+
+	return count;
+}
+
+/*----------------------------------------------------------------------------*/
+static ssize_t joypad_show_amux_debug(struct device *dev,
+				     struct device_attribute *attr,
+				     char *buf)
+{
+	struct platform_device *pdev  = to_platform_device(dev);
+	struct joypad *joypad = platform_get_drvdata(pdev);
+	struct analog_mux *amux = joypad->amux;
+	ssize_t pos;
+	int value;
+
+	mutex_lock(&joypad->lock);
+
+	/* disable poll driver */
+	if (joypad->enable)
+		joypad->enable = false;
+
+	if (joypad_amux_select(amux, joypad->debug_ch))
+		goto err_out;
+
+	if (iio_read_channel_processed(amux->iio_ch, &value))
+		goto err_out;
+
+	pos = sprintf(buf, "amux ch[%d], adc scale = %d, adc value = %d\n",
+			joypad->debug_ch, joypad->bt_adc_scale,
+			value * joypad->bt_adc_scale);
+	goto out;
+
+err_out:
+	pos = sprintf(buf, "error : amux setup & adc read!\n");
+out:
+	mutex_unlock(&joypad->lock);
+	return pos;
+}
+
+/*----------------------------------------------------------------------------*/
+static DEVICE_ATTR(amux_debug, S_IWUSR | S_IRUGO,
+		   joypad_show_amux_debug,
+		   joypad_store_amux_debug);
+
+/*----------------------------------------------------------------------------*/
+/*----------------------------------------------------------------------------*/
+static struct attribute *joypad_attrs[] = {
+	&dev_attr_poll_interval.attr,
+	&dev_attr_adc_fuzz.attr,
+	&dev_attr_adc_flat.attr,
+	&dev_attr_enable.attr,
+	&dev_attr_adc_cal.attr,
+	&dev_attr_amux_debug.attr,
+	NULL,
+};
+
+static struct attribute_group joypad_attr_group = {
+	.attrs = joypad_attrs,
+};
+
+/*----------------------------------------------------------------------------*/
+/*----------------------------------------------------------------------------*/
+static void joypad_gpio_check(struct input_polled_dev *poll_dev)
+{
+	struct joypad *joypad = poll_dev->private;
+	int nbtn, value;
+
+	for (nbtn = 0; nbtn < joypad->bt_gpio_count; nbtn++) {
+		struct bt_gpio *gpio = &joypad->gpios[nbtn];
+
+		if (gpio_get_value_cansleep(gpio->num) < 0) {
+			dev_err(joypad->dev, "failed to get gpio state\n");
+			continue;
+		}
+		value = gpio_get_value(gpio->num);
+		if (value != gpio->old_value) {
+			input_event(poll_dev->input,
+				gpio->report_type,
+				gpio->linux_code,
+				(value == gpio->active_level) ? 1 : 0);
+			gpio->old_value = value;
+		}
+	}
+	input_sync(poll_dev->input);
+}
+
+/*----------------------------------------------------------------------------*/
+static void joypad_adc_check(struct input_polled_dev *poll_dev)
+{
+	struct joypad *joypad = poll_dev->private;
+	int nbtn;
+
+	for (nbtn = 0; nbtn < joypad->amux_count; nbtn++) {
+		struct bt_adc *adc = &joypad->adcs[nbtn];
+
+		adc->value = joypad_adc_read(joypad->amux, adc);
+		if (!adc->value) {
+			dev_err(joypad->dev, "%s : saradc channels[%d]!\n",
+				__func__, nbtn);
+			continue;
+		}
+		adc->value = adc->value - adc->cal;
+
+		/* Joystick Deadzone check */
+		if (joypad->bt_adc_deadzone) {
+			if (abs(adc->value) < joypad->bt_adc_deadzone)
+				adc->value = 0;
+		}
+
+		/* adc data tuning */
+		if (adc->tuning_n && adc->value < 0)
+			adc->value = ADC_DATA_TUNING(adc->value, adc->tuning_n);
+		if (adc->tuning_p && adc->value > 0)
+			adc->value = ADC_DATA_TUNING(adc->value, adc->tuning_p);
+
+		adc->value = adc->value > adc->max ? adc->max : adc->value;
+		adc->value = adc->value < adc->min ? adc->min : adc->value;
+
+		input_report_abs(poll_dev->input,
+			adc->report_type,
+			adc->invert ? adc->value * (-1) : adc->value);
+	}
+	input_sync(poll_dev->input);
+}
+
+/*----------------------------------------------------------------------------*/
+static void joypad_poll(struct input_polled_dev *poll_dev)
+{
+	struct joypad *joypad = poll_dev->private;
+
+	if (joypad->enable) {
+		joypad_adc_check(poll_dev);
+		joypad_gpio_check(poll_dev);
+	}
+	if (poll_dev->poll_interval != joypad->poll_interval) {
+		mutex_lock(&joypad->lock);
+		poll_dev->poll_interval = joypad->poll_interval;
+		mutex_unlock(&joypad->lock);
+	}
+}
+
+/*----------------------------------------------------------------------------*/
+static void joypad_open(struct input_polled_dev *poll_dev)
+{
+	struct joypad *joypad = poll_dev->private;
+	int nbtn;
+
+	for (nbtn = 0; nbtn < joypad->bt_gpio_count; nbtn++) {
+		struct bt_gpio *gpio = &joypad->gpios[nbtn];
+		gpio->old_value = gpio->active_level ? 0 : 1;
+	}
+	for (nbtn = 0; nbtn < joypad->amux_count; nbtn++) {
+		struct bt_adc *adc = &joypad->adcs[nbtn];
+
+		adc->value = joypad_adc_read(joypad->amux, adc);
+		if (!adc->value) {
+			dev_err(joypad->dev, "%s : saradc channels[%d]!\n",
+				__func__, nbtn);
+			continue;
+		}
+		adc->cal = adc->value;
+		dev_info(joypad->dev, "%s : adc[%d] adc->cal = %d\n",
+			__func__, nbtn, adc->cal);
+	}
+	/* buttons status sync */
+	joypad_adc_check(poll_dev);
+	joypad_gpio_check(poll_dev);
+
+	/* button report enable */
+	mutex_lock(&joypad->lock);
+	joypad->enable = true;
+	mutex_unlock(&joypad->lock);
+
+	dev_info(joypad->dev, "%s : opened\n", __func__);
+}
+
+/*----------------------------------------------------------------------------*/
+static void joypad_close(struct input_polled_dev *poll_dev)
+{
+	struct joypad *joypad = poll_dev->private;
+
+	/* button report disable */
+	mutex_lock(&joypad->lock);
+	joypad->enable = false;
+	mutex_unlock(&joypad->lock);
+
+	dev_info(joypad->dev, "%s : closed\n", __func__);
+}
+
+/*----------------------------------------------------------------------------*/
+static int joypad_amux_setup(struct device *dev, struct joypad *joypad)
+{
+	struct analog_mux *amux;
+	enum iio_chan_type type;
+	enum of_gpio_flags flags;
+	int ret;
+
+	/* analog mux control struct init */
+	joypad->amux = devm_kzalloc(dev, sizeof(struct analog_mux),
+					GFP_KERNEL);
+	if (!joypad->amux) {
+		dev_err(dev, "%s amux devm_kzmalloc error!", __func__);
+		return -ENOMEM;
+	}
+	amux = joypad->amux;
+	amux->iio_ch = devm_iio_channel_get(dev, "amux_adc");
+	if (IS_ERR(amux->iio_ch)) {
+		dev_err(dev, "iio channel get error\n");
+		return -EINVAL;
+	}
+	if (!amux->iio_ch->indio_dev)
+		return -ENXIO;
+
+	if (iio_get_channel_type(amux->iio_ch, &type))
+		return -EINVAL;
+
+	if (type != IIO_VOLTAGE) {
+		dev_err(dev, "Incompatible channel type %d\n", type);
+		return -EINVAL;
+	}
+
+	amux->sel_a_gpio = of_get_named_gpio_flags(dev->of_node,
+				"amux-a-gpios", 0, &flags);
+	if (gpio_is_valid(amux->sel_a_gpio)) {
+		ret = devm_gpio_request(dev, amux->sel_a_gpio, "amux-sel-a");
+		if (ret < 0) {
+			dev_err(dev, "%s : failed to request amux-sel-a %d\n",
+				__func__, amux->sel_a_gpio);
+			goto err_out;
+		}
+		ret = gpio_direction_output(amux->sel_a_gpio, 0);
+		if (ret < 0)
+			goto err_out;
+	}
+
+	amux->sel_b_gpio = of_get_named_gpio_flags(dev->of_node,
+				"amux-b-gpios", 0, &flags);
+	if (gpio_is_valid(amux->sel_b_gpio)) {
+		ret = devm_gpio_request(dev, amux->sel_b_gpio, "amux-sel-b");
+		if (ret < 0) {
+			dev_err(dev, "%s : failed to request amux-sel-b %d\n",
+				__func__, amux->sel_b_gpio);
+			goto err_out;
+		}
+		ret = gpio_direction_output(amux->sel_b_gpio, 0);
+		if (ret < 0)
+			goto err_out;
+	}
+
+	amux->en_gpio = of_get_named_gpio_flags(dev->of_node,
+				"amux-en-gpios", 0, &flags);
+	if (gpio_is_valid(amux->en_gpio)) {
+		ret = devm_gpio_request(dev, amux->en_gpio, "amux-en");
+		if (ret < 0) {
+			dev_err(dev, "%s : failed to request amux-en %d\n",
+				__func__, amux->en_gpio);
+			goto err_out;
+		}
+		ret = gpio_direction_output(amux->en_gpio, 0);
+		if (ret < 0)
+			goto err_out;
+	}
+	return	0;
+err_out:
+	return ret;
+}
+
+/*----------------------------------------------------------------------------*/
+static int joypad_adc_setup(struct device *dev, struct joypad *joypad)
+{
+	int nbtn;
+
+	/* adc button struct init */
+	joypad->adcs = devm_kzalloc(dev, joypad->amux_count *
+				sizeof(struct bt_adc), GFP_KERNEL);
+	if (!joypad->adcs) {
+		dev_err(dev, "%s devm_kzmalloc error!", __func__);
+		return -ENOMEM;
+	}
+
+	for (nbtn = 0; nbtn < joypad->amux_count; nbtn++) {
+		struct bt_adc *adc = &joypad->adcs[nbtn];
+
+		adc->scale = joypad->bt_adc_scale;
+		
+		adc->max = (ADC_MAX_VOLTAGE / 2);
+		adc->min = (ADC_MAX_VOLTAGE / 2) * (-1);
+		if (adc->scale) {
+			adc->max *= adc->scale;
+			adc->min *= adc->scale;
+		}
+		adc->amux_ch = nbtn;
+		adc->invert = false;
+
+		switch (nbtn) {
+			case 0:
+				adc->report_type = ABS_RY;
+				if (device_property_read_u32(dev,
+					"abs_ry-p-tuning",
+					&adc->tuning_p))
+					adc->tuning_p = ADC_TUNING_DEFAULT;
+				if (device_property_read_u32(dev,
+					"abs_ry-n-tuning",
+					&adc->tuning_n))
+					adc->tuning_n = ADC_TUNING_DEFAULT;
+				break;
+			case 1:
+				adc->report_type = ABS_RX;
+				if (device_property_read_u32(dev,
+					"abs_rx-p-tuning",
+					&adc->tuning_p))
+					adc->tuning_p = ADC_TUNING_DEFAULT;
+				if (device_property_read_u32(dev,
+					"abs_rx-n-tuning",
+					&adc->tuning_n))
+					adc->tuning_n = ADC_TUNING_DEFAULT;
+				break;
+			case 2:
+				adc->report_type = ABS_Y;
+				if (device_property_read_u32(dev,
+					"abs_y-p-tuning",
+					&adc->tuning_p))
+					adc->tuning_p = ADC_TUNING_DEFAULT;
+				if (device_property_read_u32(dev,
+					"abs_y-n-tuning",
+					&adc->tuning_n))
+					adc->tuning_n = ADC_TUNING_DEFAULT;
+				break;
+			case 3:
+				adc->report_type = ABS_X;
+				if (device_property_read_u32(dev,
+					"abs_x-p-tuning",
+					&adc->tuning_p))
+					adc->tuning_p = ADC_TUNING_DEFAULT;
+				if (device_property_read_u32(dev,
+					"abs_x-n-tuning",
+					&adc->tuning_n))
+					adc->tuning_n = ADC_TUNING_DEFAULT;
+				break;
+			default :
+				dev_err(dev, "%s amux count(%d) error!",
+					__func__, nbtn);
+				return -EINVAL;
+		}
+	}
+	return	0;
+}
+
+/*----------------------------------------------------------------------------*/
+static int joypad_gpio_setup(struct device *dev, struct joypad *joypad)
+{
+	struct device_node *node, *pp;
+	int nbtn;
+
+	node = dev->of_node;
+	if (!node)
+		return -ENODEV;
+
+	joypad->gpios = devm_kzalloc(dev, joypad->bt_gpio_count *
+				sizeof(struct bt_gpio), GFP_KERNEL);
+
+	if (!joypad->gpios) {
+		dev_err(dev, "%s devm_kzmalloc error!", __func__);
+		return -ENOMEM;
+	}
+
+	nbtn = 0;
+	for_each_child_of_node(node, pp) {
+		enum of_gpio_flags flags;
+		struct bt_gpio *gpio = &joypad->gpios[nbtn++];
+		int error;
+
+		gpio->num = of_get_gpio_flags(pp, 0, &flags);
+		if (gpio->num < 0) {
+			error = gpio->num;
+			dev_err(dev, "Failed to get gpio flags, error: %d\n",
+				error);
+			return error;
+		}
+
+		/* gpio active level(key press level) */
+		gpio->active_level = (flags & OF_GPIO_ACTIVE_LOW) ? 0 : 1;
+
+		gpio->label = of_get_property(pp, "label", NULL);
+
+		if (gpio_is_valid(gpio->num)) {
+			error = devm_gpio_request_one(dev, gpio->num,
+						      GPIOF_IN, gpio->label);
+			if (error < 0) {
+				dev_err(dev,
+					"Failed to request GPIO %d, error %d\n",
+					gpio->num, error);
+				return error;
+			}
+		}
+		if (of_property_read_u32(pp, "linux,code", &gpio->linux_code)) {
+			dev_err(dev, "Button without keycode: 0x%x\n",
+				gpio->num);
+			return -EINVAL;
+		}
+		if (of_property_read_u32(pp, "linux,input-type",
+				&gpio->report_type))
+			gpio->report_type = EV_KEY;
+	}
+	if (nbtn == 0)
+		return -EINVAL;
+
+	return	0;
+}
+
+/*----------------------------------------------------------------------------*/
+static int joypad_input_setup(struct device *dev, struct joypad *joypad)
+{
+	struct input_polled_dev *poll_dev;
+	struct input_dev *input;
+	int nbtn, error;
+
+	poll_dev = devm_input_allocate_polled_device(dev);
+	if (!poll_dev) {
+		dev_err(dev, "no memory for polled device\n");
+		return -ENOMEM;
+	}
+
+	poll_dev->private	= joypad;
+	poll_dev->poll		= joypad_poll;
+	poll_dev->poll_interval	= joypad->poll_interval;
+	poll_dev->open		= joypad_open;
+	poll_dev->close		= joypad_close;
+
+	input = poll_dev->input;
+
+	input->name = DRV_NAME;
+	input->phys = DRV_NAME"/input0";
+
+	input->id.bustype = BUS_HOST;
+	input->id.vendor  = 0x0001;
+	input->id.product = 0x0001;
+	input->id.version = 0x0101;
+
+	/* IIO ADC key setup (0 mv ~ 1800 mv) * adc->scale */
+	__set_bit(EV_ABS, input->evbit);
+	for(nbtn = 0; nbtn < joypad->amux_count; nbtn++) {
+		struct bt_adc *adc = &joypad->adcs[nbtn];
+		input_set_abs_params(input, adc->report_type,
+				adc->min, adc->max,
+				joypad->bt_adc_fuzz,
+				joypad->bt_adc_flat);
+		dev_info(dev,
+			"%s : SCALE = %d, ABS min = %d, max = %d,"
+			" fuzz = %d, flat = %d, deadzone = %d\n",
+			__func__, adc->scale, adc->min, adc->max,
+			joypad->bt_adc_fuzz, joypad->bt_adc_flat,
+			joypad->bt_adc_deadzone);
+		dev_info(dev,
+			"%s : adc tuning_p = %d, adc_tuning_n = %d\n\n",
+			__func__, adc->tuning_p, adc->tuning_n);
+	}
+
+	/* GPIO key setup */
+	__set_bit(EV_KEY, input->evbit);
+	for(nbtn = 0; nbtn < joypad->bt_gpio_count; nbtn++) {
+		struct bt_gpio *gpio = &joypad->gpios[nbtn];
+		input_set_capability(input, gpio->report_type,
+				gpio->linux_code);
+	}
+
+	if (joypad->auto_repeat)
+		__set_bit(EV_REP, input->evbit);
+
+	joypad->dev = dev;
+
+	error = input_register_polled_device(poll_dev);
+	if (error) {
+		dev_err(dev, "unable to register polled device, err=%d\n",
+			error);
+		return error;
+	}
+	return 0;
+}
+
+/*----------------------------------------------------------------------------*/
+static void joypad_setup_value_check(struct device *dev, struct joypad *joypad)
+{
+	/*
+		fuzz: specifies fuzz value that is used to filter noise from
+			the event stream.
+	*/
+	if (g_button_adc_fuzz)
+		joypad->bt_adc_fuzz = g_button_adc_fuzz;
+	else
+		device_property_read_u32(dev, "button-adc-fuzz",
+					&joypad->bt_adc_fuzz);
+	/*
+		flat: values that are within this value will be discarded by
+			joydev interface and reported as 0 instead.
+	*/
+	if (g_button_adc_flat)
+		joypad->bt_adc_flat = g_button_adc_flat;
+	else
+		device_property_read_u32(dev, "button-adc-flat",
+					&joypad->bt_adc_flat);
+
+	/* Joystick report value control */
+	if (g_button_adc_scale)
+		joypad->bt_adc_scale = g_button_adc_scale;
+	else
+		device_property_read_u32(dev, "button-adc-scale",
+					&joypad->bt_adc_scale);
+
+	/* Joystick deadzone value control */
+	if (g_button_adc_deadzone)
+		joypad->bt_adc_deadzone = g_button_adc_deadzone;
+	else
+		device_property_read_u32(dev, "button-adc-deadzone",
+					&joypad->bt_adc_deadzone);
+
+}
+
+/*----------------------------------------------------------------------------*/
+static int joypad_dt_parse(struct device *dev, struct joypad *joypad)
+{
+	int error = 0;
+
+	/* initialize value check from boot.ini */
+	joypad_setup_value_check(dev, joypad);
+
+	device_property_read_u32(dev, "amux-count",
+				&joypad->amux_count);
+
+	device_property_read_u32(dev, "poll-interval",
+				&joypad->poll_interval);
+
+	joypad->auto_repeat = device_property_present(dev, "autorepeat");
+
+	joypad->bt_gpio_count = device_get_child_node_count(dev);
+
+	if ((joypad->amux_count == 0) || (joypad->bt_gpio_count == 0)) {
+		dev_err(dev, "adc key = %d, gpio key = %d error!",
+			joypad->amux_count, joypad->bt_gpio_count);
+		return -EINVAL;
+	}
+
+	error = joypad_adc_setup(dev, joypad);
+	if (error)
+		return error;
+
+	error = joypad_amux_setup(dev, joypad);
+	if (error)
+		return error;
+
+	error = joypad_gpio_setup(dev, joypad);
+	if (error)
+		return error;
+
+	dev_info(dev, "%s : adc key cnt = %d, gpio key cnt = %d\n",
+			__func__, joypad->amux_count, joypad->bt_gpio_count);
+
+	return error;
+}
+
+/*----------------------------------------------------------------------------*/
+static int joypad_probe(struct platform_device *pdev)
+{
+	struct joypad *joypad;
+	struct device *dev = &pdev->dev;
+	int error;
+
+	joypad = devm_kzalloc(dev, sizeof(struct joypad), GFP_KERNEL);
+	if (!joypad) {
+		dev_err(dev, "joypad devm_kzmalloc error!");
+		return -ENOMEM;
+	}
+
+	/* device tree data parse */
+	error = joypad_dt_parse(dev, joypad);
+	if (error) {
+		dev_err(dev, "dt parse error!(err = %d)\n", error);
+		return error;
+	}
+
+	mutex_init(&joypad->lock);
+	platform_set_drvdata(pdev, joypad);
+
+	error = sysfs_create_group(&pdev->dev.kobj, &joypad_attr_group);
+	if (error) {
+		dev_err(dev, "create sysfs group fail, error: %d\n",
+			error);
+		return error;
+	}
+
+	/* poll input device setup */
+	error = joypad_input_setup(dev, joypad);
+	if (error) {
+		dev_err(dev, "input setup failed!(err = %d)\n", error);
+		return error;
+	}
+	dev_info(dev, "%s : probe success\n", __func__);
+	return 0;
+}
+
+/*----------------------------------------------------------------------------*/
+static const struct of_device_id joypad_of_match[] = {
+	{ .compatible = "odroidgo3-joypad", },
+	{},
+};
+
+MODULE_DEVICE_TABLE(of, joypad_of_match);
+
+/*----------------------------------------------------------------------------*/
+static struct platform_driver joypad_driver = {
+	.probe = joypad_probe,
+	.driver = {
+		.name = DRV_NAME,
+		.of_match_table = of_match_ptr(joypad_of_match),
+	},
+};
+
+/*----------------------------------------------------------------------------*/
+static int __init joypad_init(void)
+{
+	return platform_driver_register(&joypad_driver);
+}
+
+/*----------------------------------------------------------------------------*/
+static void __exit joypad_exit(void)
+{
+	platform_driver_unregister(&joypad_driver);
+}
+
+/*----------------------------------------------------------------------------*/
+late_initcall(joypad_init);
+module_exit(joypad_exit);
+
+/*----------------------------------------------------------------------------*/
+MODULE_AUTHOR("Hardkernel Co.,LTD");
+MODULE_DESCRIPTION("Keypad driver(ADC&GPIO) for ODROIDGO-Advance");
+MODULE_LICENSE("GPL v2");
+MODULE_ALIAS("platform:" DRV_NAME);
+
+/*----------------------------------------------------------------------------*/
diff -rupN linux.orig/drivers/power/supply/rk817_charger.c linux/drivers/power/supply/rk817_charger.c
--- linux.orig/drivers/power/supply/rk817_charger.c	2023-10-27 21:46:02.984594866 +0000
+++ linux/drivers/power/supply/rk817_charger.c	2023-10-28 04:02:49.341614140 +0000
@@ -679,7 +679,7 @@ static enum power_supply_usb_type rk817_
 };
 
 static const struct power_supply_desc rk817_bat_desc = {
-	.name = "rk817-battery",
+	.name = "battery",
 	.type = POWER_SUPPLY_TYPE_BATTERY,
 	.properties = rk817_bat_props,
 	.num_properties = ARRAY_SIZE(rk817_bat_props),
diff -rupN linux.orig/include/linux/input-polldev.h linux/include/linux/input-polldev.h
--- linux.orig/include/linux/input-polldev.h	1970-01-01 00:00:00.000000000 +0000
+++ linux/include/linux/input-polldev.h	2023-10-28 04:02:49.341614140 +0000
@@ -0,0 +1,58 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+#ifndef _INPUT_POLLDEV_H
+#define _INPUT_POLLDEV_H
+
+/*
+ * Copyright (c) 2007 Dmitry Torokhov
+ */
+
+#include <linux/input.h>
+#include <linux/workqueue.h>
+
+/**
+ * struct input_polled_dev - simple polled input device
+ * @private: private driver data.
+ * @open: driver-supplied method that prepares device for polling
+ *	(enabled the device and maybe flushes device state).
+ * @close: driver-supplied method that is called when device is no
+ *	longer being polled. Used to put device into low power mode.
+ * @poll: driver-supplied method that polls the device and posts
+ *	input events (mandatory).
+ * @poll_interval: specifies how often the poll() method should be called.
+ *	Defaults to 500 msec unless overridden when registering the device.
+ * @poll_interval_max: specifies upper bound for the poll interval.
+ *	Defaults to the initial value of @poll_interval.
+ * @poll_interval_min: specifies lower bound for the poll interval.
+ *	Defaults to 0.
+ * @input: input device structure associated with the polled device.
+ *	Must be properly initialized by the driver (id, name, phys, bits).
+ *
+ * Polled input device provides a skeleton for supporting simple input
+ * devices that do not raise interrupts but have to be periodically
+ * scanned or polled to detect changes in their state.
+ */
+struct input_polled_dev {
+	void *private;
+
+	void (*open)(struct input_polled_dev *dev);
+	void (*close)(struct input_polled_dev *dev);
+	void (*poll)(struct input_polled_dev *dev);
+	unsigned int poll_interval; /* msec */
+	unsigned int poll_interval_max; /* msec */
+	unsigned int poll_interval_min; /* msec */
+
+	struct input_dev *input;
+
+/* private: */
+	struct delayed_work work;
+
+	bool devres_managed;
+};
+
+struct input_polled_dev *input_allocate_polled_device(void);
+struct input_polled_dev *devm_input_allocate_polled_device(struct device *dev);
+void input_free_polled_device(struct input_polled_dev *dev);
+int input_register_polled_device(struct input_polled_dev *dev);
+void input_unregister_polled_device(struct input_polled_dev *dev);
+
+#endif
